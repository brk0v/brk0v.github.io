<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  4. getaddrinfo() from glibc
  #


    
        Last updated: Oct 2025
    

Contents

4.1 Internals and design
4.2 Name Service Switch (nss)
4.3 Name service cache daemon NSCD
4.4 Thread safety issues with getaddrinfo()
4.5. /etc/resolv.conf
4.6. /etc/hosts


The standard in POSIX describes only the behavior and interface of the getaddrinfo() function. However, the actual implementation can vary between different frameworks. In this chapter, we will examine the internals of the getaddrinfo() implementation from glibc version 2.39. In the GNU/Linux world the glibc remains the default C library for the overwhelming majority of systems."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://biriukov.dev/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/"><meta property="og:site_name" content="Viacheslav Biriukov"><meta property="og:title" content="getaddrinfo() from glibc"><meta property="og:description" content="4. getaddrinfo() from glibc # Last updated: Oct 2025 Contents
4.1 Internals and design 4.2 Name Service Switch (nss) 4.3 Name service cache daemon NSCD 4.4 Thread safety issues with getaddrinfo() 4.5. /etc/resolv.conf 4.6. /etc/hosts The standard in POSIX describes only the behavior and interface of the getaddrinfo() function. However, the actual implementation can vary between different frameworks. In this chapter, we will examine the internals of the getaddrinfo() implementation from glibc version 2.39. In the GNU/Linux world the glibc remains the default C library for the overwhelming majority of systems."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>getaddrinfo() from glibc | Viacheslav Biriukov</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.1e13c2d8521416f2409b2e0e47b515c4ee90f2718cddd31ea96d2f739bc9d7e1.css integrity="sha256-HhPC2FIUFvJAmy4OR7UVxO6Q8nGM3dMeqW0vc5vJ1+E=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fbc32a4965d5fb0c5d6768637844611554b49cbaa2fb2228bcd5552c3d9d78d1.js integrity="sha256-+8MqSWXV+wxdZ2hjeERhFVS0nLqi+yIovNVVLD2deNE=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-599VSLESJL")</script><link rel=stylesheet href=/my_css/cookie.css><link rel=stylesheet href=/my_css/copy-code.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Viacheslav Biriukov</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>DNS resolvers and Dual-Stack applications</span><ul><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/>Resolvers and Dual-Stack applications for SRE</a></li><li><a href=/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/>1. What is a stub resolver?</a></li><li><a href=/docs/resolver-dual-stack-application/2-history-gethostbyname/>2. History: gethostbyname()</a></li><li><a href=/docs/resolver-dual-stack-application/3-getaddrinfo-and-posix-spec/>3. getaddrinfo() and POSIX spec</a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/ class=active>4. getaddrinfo() from glibc</a></li><li><a href=/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/>5. getaddrinfo() from musl libc</a></li><li><a href=/docs/resolver-dual-stack-application/6-dual-stack-applications/>6. Dual-Stack applications</a></li><li><a href=/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/>7. C async non-blocking resolvers</a></li><li><a href=/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/>8. Stub resolvers in languages</a></li><li><a href=/docs/resolver-dual-stack-application/9-dual-stack-software-examples/>9. Dual-stack software examples</a></li><li><a href=/docs/resolver-dual-stack-application/10-systemd-resolved/>10. systemd-resolved</a></li><li><a href=/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/>11. Querying Nameservers</a></li><li><a href=/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/>12. Present and future</a></li><li><a href=/docs/resolver-dual-stack-application/troubleshooting-tools-for-resolvers-and-dns/>Troubleshooting tools</a></li></ul></li></ul><div style=margin-top:30px;margin-bottom:30px><b>More recent series:</b><ul><li><a href=/rust-tokio-io/>1. Async Rust & Tokio I/O Streams: Backpressure, Concurrency, and Ergonomics&nbsp;<span style="padding:0 2px;border-radius:2px;background-color:#e84118;color:#f0f8ff">new</span></li><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/>2. Resolvers and Dual-Stack applications</li><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>3. Linux Page Cache mini book</li><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons>4. File descriptors, pipes, terminals, user sessions, process groups and daemons</li></ul></div><div style=margin-top:30px;margin-bottom:30px><b>Open Source Projects</b><ul><li><a href=https://github.com/brk0v/trixter/tree/main>• trixter chaos proxy</a></li><li><a href=https://crates.io/crates/tokio-netem>• tokio-netem</a></li></ul></div><ul><li><a href=https://twitter.com/brk0v/ target=_blank rel=noopener><i class="bi bi-twitter"></i>
Twitter</a></li><li><a href=https://www.linkedin.com/in/biriukov/ target=_blank rel=noopener><i class="bi bi-linkedin"></i>
Linkedin</a></li><li><a href=https://github.com/brk0v/ target=_blank rel=noopener><i class="bi bi-github"></i>
Github</a></li></ul><div style=margin-top:30px><p xmlns:cc=http://creativecommons.org/ns#>This content is licensed under
<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-NC 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"></a></p></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>getaddrinfo() from glibc</strong>
<label for=toc-control></label></div></header><article class="markdown book-article"><h1 id=4-getaddrinfo-from-glibc>4. <code>getaddrinfo()</code> from <code>glibc</code>
<a class=anchor href=#4-getaddrinfo-from-glibc>#</a></h1><p class=updated-right><i><time datetime=2025-10>Last updated: Oct 2025</time></i></p><p><strong>Contents</strong></p><ul><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/#41-internals-and-design>4.1 Internals and design</a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/#42-name-service-switch-nss>4.2 Name Service Switch (<code>nss</code>)</a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/#43-name-service-cache-daemon-nscd>4.3 Name service cache daemon <code>NSCD</code></a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/#44-thread-safety-issues-with-getaddrinfo>4.4 Thread safety issues with <code>getaddrinfo()</code></a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/#45-etcresolvconf>4.5. <code>/etc/resolv.conf</code></a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/#46-etchosts>4.6. <code>/etc/hosts</code></a></li></ul><hr><p>The standard in POSIX describes only the behavior and interface of the <code>getaddrinfo()</code> function. However, the actual implementation can vary between different frameworks. In this chapter, we will examine the internals of the <code>getaddrinfo()</code> implementation from <code>glibc</code> version 2.39. In the GNU/Linux world the <code>glibc</code> remains the default C library for the overwhelming majority of systems.</p><h2 id=41-internals-and-design>4.1 Internals and design
<a class=anchor href=#41-internals-and-design>#</a></h2><p>Even though the main purpose of a stub resolver is to send DNS queries to a recursive server, the reality is more complex than that. The chart below illustrates the main steps that the <code>glibc</code> <code>getaddrinfo()</code> function performs each time you call it.</p><img alt="`glibc` `getaddrinfo()` internals with Name Service Switch (`nss`)" src=../images/getaddrinfo-glibc.png width=60% class=img-center><div class=text-center>Figure 2. – <code>glibc</code> <code>getaddrinfo()</code> internals with Name Service Switch (NSS).</div><p>① – The first step in the process might come as a surprise: <code>getaddrinfo()</code> attempts to connect to a hardcoded path of a Unix socket each time it is called. This socket is a part of the Name Service Switch system and related to a cache daemon. We are touching it later in this section.</p><p>② – The next step involves reading the Name Service Switch configuration file, <code>/etc/nsswitch.conf</code>. This file sets the order of sources for various services, not just domain resolution. The line of interest for domain name resolution starts with the keyword &ldquo;<code>hosts</code>&rdquo;. Subsequent words identify NSS modules, which are queried from left to right in the specified order.</p><p>One important note about<code>/etc/nsswitch.conf</code> is that it includes special notation for error handling: for instance, whether to fail immediately, retry, or ignore the error and move to the next module.</p><p>In the example shown in the chart above, the <code>getaddrinfo()</code> call should first check the <code>/etc/hosts</code> file, then query the DNS name server, and finally run a <code>custom</code> module, which we are going to write.</p><p>③ – NSS modules are shared libraries that adhere to the <a href=https://www.gnu.org/software/libc/manual/html_node/NSS-Modules-Interface.html target=_blank rel=noopener>NSS Modules Interface</a> and are named accordingly to a template defined in the <code><a href=https://man7.org/linux/man-pages/man5/nsswitch.conf.5.html target=_blank rel=noopener>man 5 nsswitch.conf</a></code>.</p><p>④ – The final step is sorting destination addresses according to ten rules from <a href=https://datatracker.ietf.org/doc/html/rfc6724#section-6 target=_blank rel=noopener>RFC 6724</a>, which we will discuss in more detail in the chapter on dual-stack implementation.</p><h2 id=42-name-service-switch-nss>4.2 Name Service Switch (nss)
<a class=anchor href=#42-name-service-switch-nss>#</a></h2><p><a href=https://en.wikipedia.org/wiki/Name_Service_Switch target=_blank rel=noopener>Name service switch (NSS)</a> is a framework used to manage the sources from which various name service information is obtained and is which order it’s requested. The system configuration file for NSS is located at <code>/etc/nsswitch.conf</code> (<code><a href=https://man7.org/linux/man-pages/man5/nsswitch.conf.5.html target=_blank rel=noopener>man 5 nsswitch.conf</a></code>).</p><blockquote><p>The Name Service Switch (NSS) configuration file, <code>/etc/nsswitch.conf</code>, is used by the GNU C Library and certain other applications to determine the sources from which to obtain name-service information in a range of categories, and in what order. Each category of information is identified by a database name.</p></blockquote><p>It’s possible to write your own NSS module. The module is a shared library that adheres to a defined <a href=https://www.gnu.org/software/libc/manual/html_node/NSS-Modules-Interface.html target=_blank rel=noopener>API</a> and should be named and placed according to the following format from the <code><a href=https://man7.org/linux/man-pages/man5/nsswitch.conf.5.html target=_blank rel=noopener>man 5 nsswitch.conf</a></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>/lib/libnss_custom.so.2
</span></span></code></pre></div><p>for a module named <code>custom</code>.</p><p>Now we are ready to write our own NSS module for the <code>host</code> subsystem. We will need a great <code>Rust</code> library <a href=https://github.com/csnewman/libnss-rs/tree/master target=_blank rel=noopener>libnss-rs</a>.</p><p>The step-by-step instructions:</p><p>Install <code>rust</code> and <code>gcc</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl --proto <span style=color:#e6db74>&#39;=https&#39;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh
</span></span><span style=display:flex><span>sudo apt-get install gcc
</span></span></code></pre></div><p>We are naming our module <a href=https://tolkiengateway.net/wiki/Gildor target=_blank rel=noopener>gildor</a> 🧝‍♂:</p><p>Dependencies:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#66d9ef>[lib]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;nss_gildor&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>crate-type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>[ &#34;cdylib&#34; ]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[dependencies]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>libc</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0.2.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>libnss</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;0.8.0&#34;</span>
</span></span></code></pre></div><p>Code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> libnss::host::{AddressFamily, Addresses, Host, HostHooks};
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> libnss::libnss_host_hooks;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> libnss::interop::Response;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::net::{IpAddr, Ipv4Addr};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>HardcodedHost</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>libnss_host_hooks!</span>(gildor, HardcodedHost);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> HostHooks <span style=color:#66d9ef>for</span> HardcodedHost {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_all_entries</span>() -&gt; <span style=color:#a6e22e>Response</span><span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>Host<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>        Response::Success(<span style=color:#a6e22e>vec!</span>[Host {
</span></span><span style=display:flex><span>            name: <span style=color:#e6db74>&#34;host1.example&#34;</span>.to_string(),
</span></span><span style=display:flex><span>            addresses: <span style=color:#a6e22e>Addresses</span>::V4(<span style=color:#a6e22e>vec!</span>[Ipv4Addr::new(<span style=color:#ae81ff>192</span>, <span style=color:#ae81ff>168</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)]),
</span></span><span style=display:flex><span>            aliases: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#e6db74>&#34;super-host1.example&#34;</span>.to_string()],
</span></span><span style=display:flex><span>        }])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_host_by_addr</span>(addr: <span style=color:#a6e22e>IpAddr</span>) -&gt; <span style=color:#a6e22e>Response</span><span style=color:#f92672>&lt;</span>Host<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> addr {
</span></span><span style=display:flex><span>            IpAddr::V4(addr) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> addr.octets() <span style=color:#f92672>==</span> [<span style=color:#ae81ff>192</span>, <span style=color:#ae81ff>168</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>] {
</span></span><span style=display:flex><span>                    Response::Success(Host {
</span></span><span style=display:flex><span>                        name: <span style=color:#e6db74>&#34;host1.example&#34;</span>.to_string(),
</span></span><span style=display:flex><span>                        addresses: <span style=color:#a6e22e>Addresses</span>::V4(<span style=color:#a6e22e>vec!</span>[Ipv4Addr::new(<span style=color:#ae81ff>192</span>, <span style=color:#ae81ff>168</span>,<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)]),
</span></span><span style=display:flex><span>                        aliases: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#e6db74>&#34;super-host1.example&#34;</span>.to_string()],
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    Response::NotFound
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            _ <span style=color:#f92672>=&gt;</span> Response::NotFound,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_host_by_name</span>(name: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>, family: <span style=color:#a6e22e>AddressFamily</span>) -&gt; <span style=color:#a6e22e>Response</span><span style=color:#f92672>&lt;</span>Host<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> name.ends_with(<span style=color:#e6db74>&#34;.example&#34;</span>) <span style=color:#f92672>&amp;&amp;</span> family <span style=color:#f92672>==</span> AddressFamily::IPv4 {
</span></span><span style=display:flex><span>            Response::Success(Host {
</span></span><span style=display:flex><span>                name: <span style=color:#a6e22e>name</span>.to_string(),
</span></span><span style=display:flex><span>                addresses: <span style=color:#a6e22e>Addresses</span>::V4(<span style=color:#a6e22e>vec!</span>[Ipv4Addr::new(<span style=color:#ae81ff>192</span>, <span style=color:#ae81ff>168</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>)]),
</span></span><span style=display:flex><span>                aliases: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[<span style=color:#e6db74>&#34;host1.example&#34;</span>.to_string(), <span style=color:#e6db74>&#34;super-host1.example&#34;</span>.to_string()],
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Response::NotFound
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We also need an install script to put our library in the correct place:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat install.sh
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>cd target/release
</span></span><span style=display:flex><span>cp libnss_gildor.so libnss_gildor.so.2
</span></span><span style=display:flex><span>sudo install -m <span style=color:#ae81ff>0644</span> libnss_gildor.so.2 /lib
</span></span><span style=display:flex><span>sudo /sbin/ldconfig -n /lib /usr/lib
</span></span></code></pre></div><p>It’s time to enable our module in <code>/etc/nsswitch.conf:</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /etc/nsswitch.conf | grep hosts:
</span></span><span style=display:flex><span>hosts:          gildor dns files
</span></span></code></pre></div><p>And query <code>NSS</code> with <code>getent</code> (<code><a href=https://man7.org/linux/man-pages/man1/getent.1.html target=_blank rel=noopener>man 1 getent</a></code>) tool:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ getent ahosts host1.example
</span></span><span style=display:flex><span>192.168.1.1   STREAM host1.example
</span></span><span style=display:flex><span>192.168.1.1   DGRAM
</span></span><span style=display:flex><span>192.168.1.1   RAW
</span></span></code></pre></div><h2 id=43-name-service-cache-daemon-nscd>4.3 Name service cache daemon <code>NSCD</code>
<a class=anchor href=#43-name-service-cache-daemon-nscd>#</a></h2><p>If we revisit our example from Chapter 3 and examine the output of <code>strace</code> more carefully, we can find the following lines:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo strace -T -tt ./getaddrinfo microsoft.com 2&gt;&amp;<span style=color:#ae81ff>1</span> | grep nscd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>21:03:57.515650 connect<span style=color:#f92672>(</span>3, <span style=color:#f92672>{</span>sa_family<span style=color:#f92672>=</span>AF_UNIX, sun_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/var/run/nscd/socket&#34;</span><span style=color:#f92672>}</span>, 110<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> -1 ENOENT <span style=color:#f92672>(</span>No such file or directory<span style=color:#f92672>)</span> &lt;0.000102&gt;
</span></span><span style=display:flex><span>21:03:57.516376 connect<span style=color:#f92672>(</span>3, <span style=color:#f92672>{</span>sa_family<span style=color:#f92672>=</span>AF_UNIX, sun_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/var/run/nscd/socket&#34;</span><span style=color:#f92672>}</span>, 110<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> -1 ENOENT <span style=color:#f92672>(</span>No such file or directory<span style=color:#f92672>)</span> &lt;0.000053&gt;
</span></span><span style=display:flex><span>21:03:57.521218 connect<span style=color:#f92672>(</span>3, <span style=color:#f92672>{</span>sa_family<span style=color:#f92672>=</span>AF_UNIX, sun_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/var/run/nscd/socket&#34;</span><span style=color:#f92672>}</span>, 110<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> -1 ENOENT <span style=color:#f92672>(</span>No such file or directory<span style=color:#f92672>)</span> &lt;0.000053&gt;
</span></span><span style=display:flex><span>21:03:57.521794 connect<span style=color:#f92672>(</span>3, <span style=color:#f92672>{</span>sa_family<span style=color:#f92672>=</span>AF_UNIX, sun_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/var/run/nscd/socket&#34;</span><span style=color:#f92672>}</span>, 110<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> -1 ENOENT <span style=color:#f92672>(</span>No such file or directory<span style=color:#f92672>)</span> &lt;0.000050&gt;
</span></span></code></pre></div><p>There are multiple attempts to connect over the UNIX socket to the <code>/var/run/nscd/socket</code> path, which usually doesn’t exist by default. The output shows that, on average, each call took 0.000050 seconds.</p><p>The UNIX socket at<code>/var/run/nscd/socket</code> is part of <code>glibc</code> and the Name Service Cache Daemon (<code>nscd</code>), which is known for its instability and frequent bugs. As a result, it is often avoided. However, there are alternatives, and if you cannot afford to spend 0.000050 seconds on every <code>getaddrinfo()</code> call, you might consider installing them or replacing the stub resolver. Fortunately, everything is open source.</p><h2 id=44-thread-safety-issues-with-getaddrinfo>4.4 Thread safety issues with <code>getaddrinfo()</code>
<a class=anchor href=#44-thread-safety-issues-with-getaddrinfo>#</a></h2><p>It’s worth noting that you should be cautious when calling <code>getaddrinfo()</code> in a multithreaded application, as <code>getaddrinfo()</code> invokes <code>getenv()</code>. This is detailed in the <code>resolv.conf</code> (<code><a href=https://man7.org/linux/man-pages/man5/resolv.conf.5.html target=_blank rel=noopener>man 5 resolv.conf</a></code>).</p><blockquote><p>The search keyword of a system&rsquo;s resolv.conf file can be overridden on a per-process basis by setting the environment variable <code>LOCALDOMAIN</code> to a space-separated list of search domains.</p><p>The options keyword of a system&rsquo;s resolv.conf file can be amended on a per-process basis by setting the environment variable <code>RES_OPTIONS</code> to a space-separated list of resolver options as explained above under options.</p></blockquote><p>So there are two environment variables: <code>LOCALDOMAIN</code> and <code>RES_OPTIONS</code>. This means that <code>getaddrinfo()</code> calls <code>getenv()</code>internally, but <code>setenv()</code> is not thread safe according to its own <a href=https://man7.org/linux/man-pages/man3/setenv.3.html target=_blank rel=noopener>man</a>.</p><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>setenv<span style=color:#f92672>()</span>, unsetenv<span style=color:#f92672>()</span>    │ Thread safety │ MT-Unsafe const:env
</span></span></code></pre></div></blockquote><p>So if you have two threads in an application where one is resolving a domain name and the other is setting environment variables using <code>setenv()</code>, you might encounter a segmentation fault.</p><p>This is particularly relevant for <code>Golang</code> applications, which are typically multithreaded by default due to the design of language and goroutines. An example of this issue can be seen in an open issue with the <code>cgo</code> stub resolver: <a href=https://github.com/golang/go/issues/63567 target=_blank rel=noopener>https://github.com/golang/go/issues/63567</a>.</p><h2 id=45-etcresolvconf>4.5. <code>/etc/resolv.conf</code>
<a class=anchor href=#45-etcresolvconf>#</a></h2><p>Technically, <code>/etc/resolv.conf</code> is not part of <code>glibc</code>; it is a system configuration file used by all known resolvers. However, I’ve chosen to discuss it in the <code>glibc</code> section because it is often challenging to unwind the dependencies and relationships due to the interconnections and interoperability between components (for example, <code>glibc</code> resolver library <code><a href=https://man7.org/linux/man-pages/man3/resolver.3.html target=_blank rel=noopener>man 3 resolver</a></code>).</p><p>The man page for <code>/etc/resolv.conf</code> (<code><a href=https://man7.org/linux/man-pages/man5/resolv.conf.5.html target=_blank rel=noopener>man 5 resolv.conf</a></code>) includes several important configuration parameters that could save you hours of debugging and troubleshooting:</p><ul><li><p><code>nameserver</code> – parameter allows you to specify up to three nameservers, which will be queried in sequence. Note that in contrast, the <code><a href=https://www.musl-libc.org/ target=_blank rel=noopener>musl libc</a></code> implementation queries all specified nameservers in parallel (see the <code>musl libc</code> chapter below for details).</p><blockquote><p>The algorithm used is to try a name server, and if the query times out, try the next, until out of name servers, then repeat trying all the name servers until a maximum number of retries are made.</p></blockquote></li><li><p><code>search</code> – it’s a search list of domains to use for a hostname lookup.</p><blockquote><p>Resolver queries having fewer than <code>ndots</code> dots (default is 1) in them will be attempted using each component of the search path in turn until a match is found.</p></blockquote><p>This means that if the domain name used in <code>getaddrinfo()</code> contains fewer than the specified <code>ndots</code> (explained further below), the resolver will append the <code>search</code> domain from the list and attempt to resolve it first.</p></li><li><p><code>domain</code> – is the obsolete version of <code>search</code>.</p></li><li><p>The options <code>ndots:n</code> – specifies the minimum number of dots a domain name must have to avoid automatically appending the search domain to the name being resolved. The default setting is 1, meaning the only way to trigger the addition of a search domain is to attempt to resolve a hostname that contains no dots. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /etc/resolv.conf | grep search
</span></span><span style=display:flex><span>search mydomain
</span></span></code></pre></div></li></ul><p>If we try now to resolve a hostname without a domain name:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ getent ahosts resolve-me
</span></span></code></pre></div><p>In <code>tcpdump</code> you should see a number of queries:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ tcpdump -s0 -i any -n -A dst port <span style=color:#ae81ff>53</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>08:15:42.289500 lo    In  IP 127.0.0.1.43396 &gt; 127.0.0.53.53: 4492+ <span style=color:#f92672>[</span>1au<span style=color:#f92672>]</span> A? resolve-me.mydomain. <span style=color:#f92672>(</span>48<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>08:15:42.289517 lo    In  IP 127.0.0.1.43396 &gt; 127.0.0.53.53: 51586+ <span style=color:#f92672>[</span>1au<span style=color:#f92672>]</span> AAAA? resolve-me.mydomain. <span style=color:#f92672>(</span>48<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>08:15:42.421518 lo    In  IP 127.0.0.1.57952 &gt; 127.0.0.53.53: 48456+ <span style=color:#f92672>[</span>1au<span style=color:#f92672>]</span> A? resolve-me. <span style=color:#f92672>(</span>39<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>08:15:42.421526 lo    In  IP 127.0.0.1.57952 &gt; 127.0.0.53.53: 40777+ <span style=color:#f92672>[</span>1au<span style=color:#f92672>]</span> AAAA? resolve-me. <span style=color:#f92672>(</span>39<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The output shows that the first two requests for <code>A</code> and <code>AAAA</code> were sent with the search domain appended.</p><ul><li><code>options edns0</code> – enables DNS extensions described in <a href=https://datatracker.ietf.org/doc/html/rfc2671 target=_blank rel=noopener>RFC 2671</a> which brings more efficient query and response handling.</li><li><code>options timeout:n </code>– how long to wait for an answer from a <code>nameserver</code> before sending a query to the next in-order. The default is 5 seconds.</li><li><code>options attempts:n</code> – how many times to retry a <code>nameserver</code> before switching to the next one. Default is 2 times.</li><li><code>options rotate</code> – don’t start from the first <code>nameserver</code> every time, instead apply a round-robin algorithm.</li></ul><p>As we wrap up this chapter, I’d like to highlight a potential resolver issue related to the <code>ndots</code> setting in Kubernetes environments, where <code>/etc/resolv.conf</code> might include multiple search domains, and <code>ndots</code> may be set higher than the default one dot.</p><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /etc/resolv.conf
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>search namespace.svc.cluster.local svc.cluster.local cluster.local
</span></span><span style=display:flex><span>options ndots:5
</span></span></code></pre></div><p>Firstly, it’s important to understand what a Fully Qualified Domain Name (FQDN) is. By convention, an FQDN should end with a trailing dot, meaning &ldquo;<code>example.com.</code>&rdquo; is a FQDN, whereas &ldquo;<code>example.com</code>&rdquo; is not. However, many applications, such as web browsers, implicitly assume the trailing dot, which makes the distinction subtle.</p><p>With the above <code>resolv.conf</code> settings, attempting to resolve &ldquo;<code>example.com</code>&rdquo; will generate six additional, unnecessary DNS queries (three for <code>A</code> records and three for <code>AAAA</code> records) for three FQDNs:</p><ul><li><code>example.com.namespace.svc.cluster.local.</code></li><li><code>example.com.svc.cluster.local.</code></li><li><code>example.com.cluster.local.</code></li></ul><p>These queries occur before resolving what we actually want: &ldquo;<code>example.com.</code>&rdquo;. This can add significant latency and increase DNS traffic. To mitigate this situation, there are at least two approaches:</p><ol><li>Modify the <code>ndots</code> option if you are confident that your application in a <code>pod</code> will not use internal DNS names: \</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>dnsConfig</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>options</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>ndots</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>value</span>: <span style=color:#e6db74>&#34;1&#34;</span>
</span></span></code></pre></div><ol start=2><li>Change all your domain names to have a trailing dot at the end in configs and databases:<br>Ensure all your domain names in configs and databases include a trailing dot at the end, such as &ldquo;<code>example.com.cluster.local.</code>&rdquo;.</li></ol><h2 id=46-etchosts>4.6. <code>/etc/hosts</code>
<a class=anchor href=#46-etchosts>#</a></h2><p>&ldquo;The well-known <code>/etc/hosts</code> (<code><a href=https://www.man7.org/linux/man-pages/man5/hosts.5.html target=_blank rel=noopener>man 5 hosts</a></code>) is a plain text file used by operating systems to map hostnames to IP addresses.</p><p>The only interesting thing I can probably share is the first hostname is the <code>canonical_hostname</code> (which is included in a <code>getaddrinfo()</code> output) and all others are aliases.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>IP_address canonical_hostname <span style=color:#f92672>[</span>aliases...<span style=color:#f92672>]</span>
</span></span></code></pre></div><a href=/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/ class="book-btn right-button">Read next chapter →</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script defer src=/my_js/copy-code.js></script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div></main><div class=cookie-container><p>This website uses "<b>cookies</b>".
Using this website means you're OK with this.
If you are <b>NOT</b>, please close the site page.</p><button class=cookie-btn>
ACCEPT AND CLOSE</button></div><script src=/my_js/cookie.js></script></body></html>