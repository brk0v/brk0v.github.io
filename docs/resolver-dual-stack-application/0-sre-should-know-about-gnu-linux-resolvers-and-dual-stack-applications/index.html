<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  What every SRE should know about GNU/Linux resolvers and Dual-Stack applications
  #


    
        Last updated: Oct 2025
    

Contents

What is a stub resolver?
History: gethostbyname() and old good friends
getaddrinfo() and POSIX spec
getaddrinfo() from glibc
getaddrinfo() from musl libc
Dual-Stack applications
Async non-blocking resolvers in C
Stub resolvers in languages
Dual-stack software examples
systemd-resolved
Querying Nameservers on dual-stack hosts
The Present and the future of resolvers and DNS related features
Tools for troubleshooting in one place


In this series of posts, I’d like to  make a deep dive into the GNU/Linux local facilities used to convert a domain name or hostname into IP addresses, specifically in the context of dual-stack applications. This process of resolution is one of the oldest forms of networking abstraction, designed to replace hard-to-remember network addresses with human-readable strings. Although it may seem simple at first glance, the entire process involving stub resolvers is filled with complexities and subtle nuances. One contributing factor to this complexity is the growing number of IPv6 addresses, which, although not increasing at the pace everyone might want, is gradually changing servers and clients to support dual-stack hosts. Thus a seamless transition to IPv6 become an important feature and should occur without degrading user experience or increasing response latency."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://biriukov.dev/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/"><meta property="og:site_name" content="Viacheslav Biriukov"><meta property="og:title" content="What every SRE should know about GNU/Linux resolvers and Dual-Stack applications"><meta property="og:description" content="What every SRE should know about GNU/Linux resolvers and Dual-Stack applications # Last updated: Oct 2025 Contents
What is a stub resolver? History: gethostbyname() and old good friends getaddrinfo() and POSIX spec getaddrinfo() from glibc getaddrinfo() from musl libc Dual-Stack applications Async non-blocking resolvers in C Stub resolvers in languages Dual-stack software examples systemd-resolved Querying Nameservers on dual-stack hosts The Present and the future of resolvers and DNS related features Tools for troubleshooting in one place In this series of posts, I’d like to make a deep dive into the GNU/Linux local facilities used to convert a domain name or hostname into IP addresses, specifically in the context of dual-stack applications. This process of resolution is one of the oldest forms of networking abstraction, designed to replace hard-to-remember network addresses with human-readable strings. Although it may seem simple at first glance, the entire process involving stub resolvers is filled with complexities and subtle nuances. One contributing factor to this complexity is the growing number of IPv6 addresses, which, although not increasing at the pace everyone might want, is gradually changing servers and clients to support dual-stack hosts. Thus a seamless transition to IPv6 become an important feature and should occur without degrading user experience or increasing response latency."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>What every SRE should know about GNU/Linux resolvers and Dual-Stack applications | Viacheslav Biriukov</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.1e13c2d8521416f2409b2e0e47b515c4ee90f2718cddd31ea96d2f739bc9d7e1.css integrity="sha256-HhPC2FIUFvJAmy4OR7UVxO6Q8nGM3dMeqW0vc5vJ1+E=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fbc32a4965d5fb0c5d6768637844611554b49cbaa2fb2228bcd5552c3d9d78d1.js integrity="sha256-+8MqSWXV+wxdZ2hjeERhFVS0nLqi+yIovNVVLD2deNE=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-599VSLESJL")</script><link rel=stylesheet href=/my_css/cookie.css><link rel=stylesheet href=/my_css/copy-code.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Viacheslav Biriukov</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>DNS resolvers and Dual-Stack applications</span><ul><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/ class=active>Resolvers and Dual-Stack applications for SRE</a></li><li><a href=/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/>1. What is a stub resolver?</a></li><li><a href=/docs/resolver-dual-stack-application/2-history-gethostbyname/>2. History: gethostbyname()</a></li><li><a href=/docs/resolver-dual-stack-application/3-getaddrinfo-and-posix-spec/>3. getaddrinfo() and POSIX spec</a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/>4. getaddrinfo() from glibc</a></li><li><a href=/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/>5. getaddrinfo() from musl libc</a></li><li><a href=/docs/resolver-dual-stack-application/6-dual-stack-applications/>6. Dual-Stack applications</a></li><li><a href=/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/>7. C async non-blocking resolvers</a></li><li><a href=/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/>8. Stub resolvers in languages</a></li><li><a href=/docs/resolver-dual-stack-application/9-dual-stack-software-examples/>9. Dual-stack software examples</a></li><li><a href=/docs/resolver-dual-stack-application/10-systemd-resolved/>10. systemd-resolved</a></li><li><a href=/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/>11. Querying Nameservers</a></li><li><a href=/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/>12. Present and future</a></li><li><a href=/docs/resolver-dual-stack-application/troubleshooting-tools-for-resolvers-and-dns/>Troubleshooting tools</a></li></ul></li></ul><div style=margin-top:30px;margin-bottom:30px><b>More recent series:</b><ul><li><a href=/rust-tokio-io/>1. Async Rust & Tokio I/O Streams: Backpressure, Concurrency, and Ergonomics&nbsp;<span style="padding:0 2px;border-radius:2px;background-color:#e84118;color:#f0f8ff">new</span></li><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/>2. Resolvers and Dual-Stack applications</li><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>3. Linux Page Cache mini book</li><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons>4. File descriptors, pipes, terminals, user sessions, process groups and daemons</li></ul></div><div style=margin-top:30px;margin-bottom:30px><b>Open Source Projects</b><ul><li><a href=https://github.com/brk0v/trixter/tree/main>• trixter chaos proxy</a></li><li><a href=https://crates.io/crates/tokio-netem>• tokio-netem</a></li></ul></div><ul><li><a href=https://twitter.com/brk0v/ target=_blank rel=noopener><i class="bi bi-twitter"></i>
Twitter</a></li><li><a href=https://www.linkedin.com/in/biriukov/ target=_blank rel=noopener><i class="bi bi-linkedin"></i>
Linkedin</a></li><li><a href=https://github.com/brk0v/ target=_blank rel=noopener><i class="bi bi-github"></i>
Github</a></li></ul><div style=margin-top:30px><p xmlns:cc=http://creativecommons.org/ns#>This content is licensed under
<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-NC 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"></a></p></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>What every SRE should know about GNU/Linux resolvers and Dual-Stack applications</strong>
<label for=toc-control></label></div></header><article class="markdown book-article"><h1 id=what-every-sre-should-know-about-gnulinux-resolvers-and-dual-stack-applications>What every SRE should know about GNU/Linux resolvers and Dual-Stack applications
<a class=anchor href=#what-every-sre-should-know-about-gnulinux-resolvers-and-dual-stack-applications>#</a></h1><p class=updated-right><i><time datetime=2025-10>Last updated: Oct 2025</time></i></p><p><strong>Contents</strong></p><ol><li><a href=/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/>What is a stub resolver?</a></li><li><a href=/docs/resolver-dual-stack-application/2-history-gethostbyname/>History: <code>gethostbyname()</code> and old good friends</a></li><li><a href=/docs/resolver-dual-stack-application/3-getaddrinfo-and-posix-spec/><code>getaddrinfo()</code> and POSIX spec</a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/><code>getaddrinfo() </code>from glibc</a></li><li><a href=/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/><code>getaddrinfo()</code> from musl libc</a></li><li><a href=/docs/resolver-dual-stack-application/6-dual-stack-applications/>Dual-Stack applications</a></li><li><a href=/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/>Async non-blocking resolvers in <code>C</code></a></li><li><a href=/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/>Stub resolvers in languages</a></li><li><a href=/docs/resolver-dual-stack-application/9-dual-stack-software-examples/>Dual-stack software examples</a></li><li><a href=/docs/resolver-dual-stack-application/10-systemd-resolved/><code>systemd-resolved</code></a></li><li><a href=/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/>Querying Nameservers on dual-stack hosts</a></li><li><a href=/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/>The Present and the future of resolvers and DNS related features</a></li><li><a href=/docs/resolver-dual-stack-application/troubleshooting-tools-for-resolvers-and-dns/>Tools for troubleshooting in one place</a></li></ol><hr><p>In this series of posts, I’d like to make a deep dive into the GNU/Linux local facilities used to convert a domain name or hostname into IP addresses, specifically in the context of dual-stack applications. This process of resolution is one of the oldest forms of networking abstraction, designed to replace hard-to-remember network addresses with human-readable strings. Although it may seem simple at first glance, the entire process involving stub resolvers is filled with complexities and subtle nuances. One contributing factor to this complexity is the growing number of IPv6 addresses, which, although not increasing at the pace everyone might want, is gradually changing servers and clients to support dual-stack hosts. Thus a seamless transition to IPv6 become an important feature and should occur without degrading user experience or increasing response latency.</p><img alt="It’s always been DNS" src=../images/dns.webp width=50% class=img-center><div class=text-center>Figure 1. – It’s always been DNS <a href=https://www.cyberciti.biz/humour/a-haiku-about-dns/ target=_blank rel=noopener>[©]</a></div><p>We will start with a brief history of resolvers, exploring how they evolved, the issues and problems that the <code>getaddrinfo()</code> aims to resolve, and what happens under the hood: how it interacts with the name service switch (<code>NSS</code>), caches results, and aids in building applications suited for a dual-stack world with both IPv4 and IPv6 address families. This abstraction and address-agnostic approach are essential to modern software development, and a sloppy implementation can lead to subtle bugs that are hard to debug in production. That’s why we will cover the dual stack applications more thoroughly from both client and server perspectives, trying to understand the order of using available destination addresses from a list of IPv4 and IPv6 addresses, and exploring algorithms to improve response latency in cases of network routing instability or misconfiguration.</p><p>We will also examine the most feature-rich alternative <code>C</code> language resolver, <code>c-ares</code>, discussing its potential advantages and why you might consider using it. However, our discussion will not be limited to <code>C</code> stub resolvers; we will also cover mainstream languages such as <code>Python</code>, <code>Go</code> (<code>Golang</code>), <code>Rust</code>, <code>Java</code>, and <code>NodeJS</code>, focusing on their internals, decisions and trade-offs.</p><p>Another important topic is how to configure and manage <code>/etc/resolv.conf</code> on modern GNU/Linux systems. At first glance, managing <code>/etc/resolv.conf</code> might seem straightforward – simply add a nameserver and a search domain. But when a system has multiple physical interfaces (e.g., LAN and WiFi) and several virtual ones such as VPN tunnels, all configured with DHCP clients, the situation becomes more complex. Each DHCP server might provide its own nameservers and a search domain, necessitating some logic to coordinate and reconcile these changes. Modern GNU/Linux distributions usually employ <code>systemd-resolved</code> to address this issue, and we will explore its capabilities.</p><p>As usual, we will touch on related topics to dual-stack programs, such as IPv4-mapped addresses, different ways to bind sockets for dual-stack servers, and how <code>systemd</code> can help manage listener sockets.</p><p>After we have gained a complete understanding of the resolving process, tools, and solutions, we will examine several popular load balancers: Nginx, Envoy (Envoyproxy), and HAProxy. These are excellent examples because they are designed to be dual-stack for both clients (downstreams) and backends (upstreams).</p><p>Finally, we’ll review some new and advanced topics not always directly related to a local stub resolver and dual stack applications but certainly important for domain name resolution and promising in terms of refining the resolving process in various directions: DNS push notifications, the new DNS resource record HTTPS, DNS over TLS (DoT), DNS over HTTPS (DoH), oblivious DNS (ODNS), and DNSSEC.</p><p>But before we kick off, here is some preparational information.</p><h2 id=setup-playground>Setup playground
<a class=anchor href=#setup-playground>#</a></h2><p>All examples in this series are runnable and represent real, working code. To follow along and experiment with the code effectively – a great way to learn – you’ll need a setup similar to mine. I use the latest LTS <a href=https://releases.ubuntu.com/noble/ target=_blank rel=noopener>Ubuntu 24.04</a> cloud image on my macOS, managed under the <a href=https://github.com/lima-vm/lima target=_blank rel=noopener>lima</a> project, which allows me to run Linux containers.</p><p>For testing domain name resolution, I’m using &ldquo;<code>microsoft.com</code>&rdquo; for all tests because it provides multiple <code>A</code> and <code>AAAA</code> records. Additionally, its DNS server shuffles records with every call, which can help easily determine if the answer is served from the cache or not.</p><a href=/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/ class="book-btn right-button">Read next chapter →</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script defer src=/my_js/copy-code.js></script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div></main><div class=cookie-container><p>This website uses "<b>cookies</b>".
Using this website means you're OK with this.
If you are <b>NOT</b>, please close the site page.</p><button class=cookie-btn>
ACCEPT AND CLOSE</button></div><script src=/my_js/cookie.js></script></body></html>