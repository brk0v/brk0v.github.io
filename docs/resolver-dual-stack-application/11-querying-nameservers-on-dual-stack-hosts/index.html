<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="11. Querying Nameservers on dual-stack hosts # The already seen RFC 8305 Happy Eyeballs Version 2: Better Connectivity Using Concurrency force the same preference for IPv6 name servers as it does for establishing new connections:
If multiple DNS server addresses are configured for the current network, the client may have the option of sending its DNS queries over IPv4 or IPv6. In keeping with the Happy Eyeballs approach, queries SHOULD be sent over IPv6 first (note that this is not referring to the sending of AAAA or A queries, but rather the address of the DNS server itself and IP version used to transport DNS messages)."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/"><meta property="og:site_name" content="Viacheslav Biriukov"><meta property="og:title" content="Querying Nameservers on dual-stack hosts"><meta property="og:description" content="11. Querying Nameservers on dual-stack hosts # The already seen RFC 8305 Happy Eyeballs Version 2: Better Connectivity Using Concurrency force the same preference for IPv6 name servers as it does for establishing new connections:
If multiple DNS server addresses are configured for the current network, the client may have the option of sending its DNS queries over IPv4 or IPv6. In keeping with the Happy Eyeballs approach, queries SHOULD be sent over IPv6 first (note that this is not referring to the sending of AAAA or A queries, but rather the address of the DNS server itself and IP version used to transport DNS messages)."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Querying Nameservers on dual-stack hosts | Viacheslav Biriukov</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.1d41906aaf37198c05e8bca85b15248be7d2a4850e770874fce9182253d6a51a.js integrity="sha256-HUGQaq83GYwF6LyoWxUki+fSpIUOdwh0/OkYIlPWpRo=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-599VSLESJL")</script><link rel=stylesheet href=/my_css/cookie.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Viacheslav Biriukov</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>DNS resolvers and Dual-Stack applications</span><ul><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/>Resolvers and Dual-Stack applications for SRE</a></li><li><a href=/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/>1. What is a stub resolver?</a></li><li><a href=/docs/resolver-dual-stack-application/2-history-gethostbyname/>2. History: gethostbyname()</a></li><li><a href=/docs/resolver-dual-stack-application/3-getaddrinfo-and-posix-spec/>3. getaddrinfo() and POSIX spec</a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/>4. getaddrinfo() from glibc</a></li><li><a href=/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/>5. getaddrinfo() from musl libc</a></li><li><a href=/docs/resolver-dual-stack-application/6-dual-stack-applications/>6. Dual-Stack applications</a></li><li><a href=/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/>7. C async non-blocking resolvers</a></li><li><a href=/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/>8. Stub resolvers in languages</a></li><li><a href=/docs/resolver-dual-stack-application/9-dual-stack-software-examples/>9. Dual-stack software examples</a></li><li><a href=/docs/resolver-dual-stack-application/10-systemd-resolved/>10. systemd-resolved</a></li><li><a href=/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/ class=active>11. Querying Nameservers</a></li><li><a href=/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/>12. Present and future</a></li><li><a href=/docs/resolver-dual-stack-application/troubleshooting-tools-for-resolvers-and-dns/>Troubleshooting tools</a></li></ul></li></ul><div style=margin-top:30px;margin-bottom:30px><b>More post series:</b><ul><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons>1. File descriptors, pipes, terminals, user sessions, process groups and daemons</li><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>2. Linux Page Cache mini book</li><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/>3. Resolvers and Dual-Stack applications <span style="padding:0 2px;border-radius:2px;background-color:#e84118;color:#f0f8ff">new</span></li></ul></div><ul><li><a href=https://twitter.com/brk0v/ target=_blank rel=noopener><i class="bi bi-twitter"></i>
Twitter</a></li><li><a href=https://www.linkedin.com/in/biriukov/ target=_blank rel=noopener><i class="bi bi-linkedin"></i>
Linkedin</a></li><li><a href=https://github.com/brk0v/ target=_blank rel=noopener><i class="bi bi-github"></i>
Github</a></li></ul><div style=margin-top:30px><p xmlns:cc=http://creativecommons.org/ns#>This content is licensed under
<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-NC 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"></a></p></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Querying Nameservers on dual-stack hosts</strong>
<label for=toc-control></label></div></header><article class="markdown book-article"><h1 id=11-querying-nameservers-on-dual-stack-hosts>11. Querying Nameservers on dual-stack hosts
<a class=anchor href=#11-querying-nameservers-on-dual-stack-hosts>#</a></h1><p>The already seen <a href=https://datatracker.ietf.org/doc/html/rfc8305 target=_blank rel=noopener>RFC 8305 Happy Eyeballs Version 2: Better Connectivity Using Concurrency</a> force the same preference for IPv6 name servers as it does for establishing new connections:</p><blockquote><p>If multiple DNS server addresses are configured for the current network, the client may have the option of sending its DNS queries over IPv4 or IPv6. In keeping with the Happy Eyeballs approach, queries SHOULD be sent over IPv6 first (note that this is not referring to the sending of <code>AAAA</code> or <code>A</code> queries, but rather the address of the DNS server itself and IP version used to transport DNS messages). If DNS queries sent to the IPv6 address do not receive responses, that address may be marked as penalized and queries can be sent to other DNS server addresses.</p></blockquote><p>But unfortunately <code>glibc</code> resolver doesn’t support this logic. From <code><a href=https://man7.org/linux/man-pages/man5/resolv.conf.5.html target=_blank rel=noopener>man 5 resolv.conf</a></code>:</p><blockquote><p>nameserver Name server IP address Internet address of a name server that the resolver should query, either an IPv4 address (in dot notation), or an IPv6 address in colon (and possibly dot) notation as per RFC 2373. Up to <code>MAXNS</code> (currently 3, see<code> &amp;lt;resolv.h></code>) name servers may be listed, one per keyword. If there are multiple servers, the resolver library queries them in the order listed. If no nameserver entries are present, the default is to use the name server on the local machine. (The algorithm used is to try a name server, and if the query times out, try the next, until out of name servers, then repeat trying all the name servers until a maximum number of retries are made.)</p></blockquote><p>This essentially means using <code>nameservers</code> in order, regardless of which IP stack version they belong to.</p><p>If we remember, the <code>musl</code> version of <code>getaddrinfo()</code> sends all requests in parallel to all nameservers. Thus we can say that their implementation is close to the <a href=https://datatracker.ietf.org/doc/html/rfc8305 target=_blank rel=noopener>RFC 8305</a>.</p><p>Unfortunately, the <code>systemd-resolved</code> also doesn’t do this as well even though it allows to configure <a href=https://www.freedesktop.org/software/systemd/man/latest/resolved.conf.html#Options target=_blank rel=noopener>DNS servers in a more flexible way</a>:</p><blockquote><p><code>DNS=</code></p><p>A space-separated list of IPv4 and IPv6 addresses to use as system DNS servers.</p><p>Each address can optionally take a port number separated with &ldquo;<code>:</code>&rdquo;, a network interface name or index separated with &ldquo;<code>%</code>&rdquo;, and a Server Name Indication (SNI) separated with &ldquo;<code>#</code>&rdquo;. When IPv6 address is specified with a port number, then the address must be in the square brackets. That is, the acceptable full formats are &ldquo;<code>111.222.333.444:9953%ifname#example.com</code>&rdquo; for IPv4 and &ldquo;<code>[1111:2222::3333]:9953%ifname#example.com</code>&rdquo; for IPv6. DNS requests are sent to one of the listed DNS servers in parallel to suitable per-link DNS servers acquired from <code>systemd-networkd.service(8)</code> or set at runtime by external applications. For compatibility reasons, if this setting is not specified, the DNS servers listed in <code>/etc/resolv.conf</code> are used instead, if that file exists and any servers are configured in it. This setting defaults to the empty list.</p></blockquote><p>But the code of choosing a DNS server to query <a href=https://github.com/systemd/systemd/blob/af5195f7a60a06af4135d5b75baae3935252abcd/src/resolve/resolved-dns-server.c#L884 target=_blank rel=noopener>is a loop</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>DnsServer <span style=color:#f92672>*</span><span style=color:#a6e22e>manager_get_dns_server</span>(Manager <span style=color:#f92672>*</span>m) {
</span></span><span style=display:flex><span>        Link <span style=color:#f92672>*</span>l;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>assert</span>(m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* Try to read updates resolv.conf */</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>manager_read_resolv_conf</span>(m);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* If no DNS server was chosen so far, pick the first one */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>m<span style=color:#f92672>-&gt;</span>current_dns_server <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* In case m-&gt;current_dns_server != m-&gt;dns_servers */</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>manager_server_is_stub</span>(m, m<span style=color:#f92672>-&gt;</span>current_dns_server))
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>manager_set_dns_server</span>(m, m<span style=color:#f92672>-&gt;</span>dns_servers);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (m<span style=color:#f92672>-&gt;</span>current_dns_server <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>               <span style=color:#a6e22e>manager_server_is_stub</span>(m, m<span style=color:#f92672>-&gt;</span>current_dns_server)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>manager_next_dns_server</span>(m, NULL);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (m<span style=color:#f92672>-&gt;</span>current_dns_server <span style=color:#f92672>==</span> m<span style=color:#f92672>-&gt;</span>dns_servers)
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>manager_set_dns_server</span>(m, NULL);
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><p>The <a href=https://nginx.org/en/ target=_blank rel=noopener>Nginx</a> allows to specify DNS servers in its config, but the addresses are asked in <a href=https://nginx.org/en/docs/http/ngx_http_core_module.html#resolver target=_blank rel=noopener>round-robin order</a> without any preferences for IPv6.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Syntax: 	resolver address ... <span style=color:#f92672>[</span>valid<span style=color:#f92672>=</span>time<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>ipv4<span style=color:#f92672>=</span>on|off<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>ipv6<span style=color:#f92672>=</span>on|off<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>status_zone<span style=color:#f92672>=</span>zone<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>Default: 	--
</span></span><span style=display:flex><span>Context: 	http, server, location
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Configures name servers used to resolve names of upstream servers into addresses, <span style=color:#66d9ef>for</span> example:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    resolver 127.0.0.1 <span style=color:#f92672>[</span>::1<span style=color:#f92672>]</span>:5353;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>The address can be specified as a domain name or IP address, with an optional port <span style=color:#f92672>(</span>1.3.1, 1.2.2<span style=color:#f92672>)</span>. If port is not specified, the port <span style=color:#ae81ff>53</span> is used. Name servers are queried in a round-robin fashion. 
</span></span></code></pre></div><p>The <code>c-ares</code> stub resolver library unfortunately also <a href=https://github.com/c-ares/c-ares/blob/341b34d140eddb98d1ffa0ecdd322b9b03fa4d83/src/lib/ares_process.c#L1043-L1050 target=_blank rel=noopener>doesn&rsquo;t prefer</a> IPv6 over IPv4 DNS server:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>ares_status_t</span> <span style=color:#a6e22e>ares__send_query</span>(<span style=color:#66d9ef>struct</span> query <span style=color:#f92672>*</span>query, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>ares_timeval_t</span> <span style=color:#f92672>*</span>now)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>…</span> 
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Choose the server to send the query to */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (channel<span style=color:#f92672>-&gt;</span>rotate) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Pull random server */</span>
</span></span><span style=display:flex><span>    server <span style=color:#f92672>=</span> <span style=color:#a6e22e>ares__random_server</span>(channel);
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* Pull server with failover behavior */</span>
</span></span><span style=display:flex><span>    server <span style=color:#f92672>=</span> <span style=color:#a6e22e>ares__failover_server</span>(channel);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>…</span> 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Therefore, this is an area open for future improvement.</p><a href=/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/ class="book-btn right-button">Read next chapter →</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div></main><div class=cookie-container><p>This website uses "<b>cookies</b>".
Using this website means you're OK with this.
If you are <b>NOT</b>, please close the site page.</p><button class=cookie-btn>
ACCEPT AND CLOSE</button></div><script src=/my_js/cookie.js></script></body></html>