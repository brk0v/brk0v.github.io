<!doctype html><html lang=en-us dir=ltr><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="7. Async non-blocking resolvers in C # Now that we’ve covered the essential theory, let’s explore alternative stub resolver libraries and frameworks for the C language. Other languages will be discussed next, but don’t skip this chapter, as it contains foundational information that will be referenced later.
7.1 getaddrinfo_a() # getaddrinfo_a (man 7 getaddrinfo_a) is an asynchronous version of getaddrinfo() but with some limitations: results can be collected by polling or notified by a signal."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="http://localhost:1313/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/"><meta property="og:site_name" content="Viacheslav Biriukov"><meta property="og:title" content="Async non-blocking resolvers in C"><meta property="og:description" content="7. Async non-blocking resolvers in C # Now that we’ve covered the essential theory, let’s explore alternative stub resolver libraries and frameworks for the C language. Other languages will be discussed next, but don’t skip this chapter, as it contains foundational information that will be referenced later.
7.1 getaddrinfo_a() # getaddrinfo_a (man 7 getaddrinfo_a) is an asynchronous version of getaddrinfo() but with some limitations: results can be collected by polling or notified by a signal."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Async non-blocking resolvers in C | Viacheslav Biriukov</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.1d41906aaf37198c05e8bca85b15248be7d2a4850e770874fce9182253d6a51a.js integrity="sha256-HUGQaq83GYwF6LyoWxUki+fSpIUOdwh0/OkYIlPWpRo=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-599VSLESJL")</script><link rel=stylesheet href=/my_css/cookie.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Viacheslav Biriukov</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>DNS resolvers and Dual-Stack applications</span><ul><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/>Resolvers and Dual-Stack applications for SRE</a></li><li><a href=/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/>1. What is a stub resolver?</a></li><li><a href=/docs/resolver-dual-stack-application/2-history-gethostbyname/>2. History: gethostbyname()</a></li><li><a href=/docs/resolver-dual-stack-application/3-getaddrinfo-and-posix-spec/>3. getaddrinfo() and POSIX spec</a></li><li><a href=/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/>4. getaddrinfo() from glibc</a></li><li><a href=/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/>5. getaddrinfo() from musl libc</a></li><li><a href=/docs/resolver-dual-stack-application/6-dual-stack-applications/>6. Dual-Stack applications</a></li><li><a href=/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/ class=active>7. C async non-blocking resolvers</a></li><li><a href=/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/>8. Stub resolvers in languages</a></li><li><a href=/docs/resolver-dual-stack-application/9-dual-stack-software-examples/>9. Dual-stack software examples</a></li><li><a href=/docs/resolver-dual-stack-application/10-systemd-resolved/>10. systemd-resolved</a></li><li><a href=/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/>11. Querying Nameservers</a></li><li><a href=/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/>12. Present and future</a></li><li><a href=/docs/resolver-dual-stack-application/troubleshooting-tools-for-resolvers-and-dns/>Troubleshooting tools</a></li></ul></li></ul><div style=margin-top:30px;margin-bottom:30px><b>More post series:</b><ul><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons>1. File descriptors, pipes, terminals, user sessions, process groups and daemons</li><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>2. Linux Page Cache mini book</li><li><a href=/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/>3. Resolvers and Dual-Stack applications <span style="padding:0 2px;border-radius:2px;background-color:#e84118;color:#f0f8ff">new</span></li></ul></div><ul><li><a href=https://twitter.com/brk0v/ target=_blank rel=noopener><i class="bi bi-twitter"></i>
Twitter</a></li><li><a href=https://www.linkedin.com/in/biriukov/ target=_blank rel=noopener><i class="bi bi-linkedin"></i>
Linkedin</a></li><li><a href=https://github.com/brk0v/ target=_blank rel=noopener><i class="bi bi-github"></i>
Github</a></li></ul><div style=margin-top:30px><p xmlns:cc=http://creativecommons.org/ns#>This content is licensed under
<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-NC 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"></a></p></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Async non-blocking resolvers in C</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#7-async-non-blocking-resolvers-in-c>7. Async non-blocking resolvers in <code>C</code></a><ul><li><a href=#71-getaddrinfo_a>7.1 <code>getaddrinfo_a()</code></a></li><li><a href=#72--c-ares-library>7.2 <code>c-ares</code> library</a><ul><li><a href=#721-essentials>7.2.1 Essentials</a></li><li><a href=#721-dual-stack-application>7.2.1 Dual stack application</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=7-async-non-blocking-resolvers-in-c>7. Async non-blocking resolvers in <code>C</code>
<a class=anchor href=#7-async-non-blocking-resolvers-in-c>#</a></h1><p>Now that we’ve covered the essential theory, let’s explore alternative stub resolver libraries and frameworks for the <code>C</code> language. Other languages will be discussed next, but don’t skip this chapter, as it contains foundational information that will be referenced later.</p><h2 id=71-getaddrinfo_a>7.1 <code>getaddrinfo_a()</code>
<a class=anchor href=#71-getaddrinfo_a>#</a></h2><p><code>getaddrinfo_a</code> (<code><a href=https://www.man7.org/linux/man-pages/man3/getaddrinfo_a.3.html target=_blank rel=noopener>man 7 getaddrinfo_a</a></code>) is an asynchronous version of <code>getaddrinfo()</code> but with some limitations: results can be collected by polling or notified by a signal.</p><p>Internally it creates a thread for each request using a <a href=https://github.com/bminor/glibc/blob/master/resolv/gai_misc.c#L418-L423 target=_blank rel=noopener>thread pool</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> <span style=color:#75715e>/* Now try to start a thread. If we fail, no big deal,
</span></span></span><span style=display:flex><span><span style=color:#75715e>because we know that there is at least one thread (us)
</span></span></span><span style=display:flex><span><span style=color:#75715e>that is working on lookup operations. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>__pthread_create</span> (<span style=color:#f92672>&amp;</span>thid, <span style=color:#f92672>&amp;</span>attr, handle_requests, NULL) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#f92672>++</span>nthreads;
</span></span></code></pre></div><p>and running original <code>getaddrinfo()</code> <a href=https://github.com/bminor/glibc/blob/fe9408087583fd7a6f61bb0dbcf2fd4e83186afa/resolv/gai_misc.c#L329 target=_blank rel=noopener>inside</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>	req<span style=color:#f92672>-&gt;</span>__return <span style=color:#f92672>=</span> <span style=color:#a6e22e>getaddrinfo</span> (req<span style=color:#f92672>-&gt;</span>ar_name, req<span style=color:#f92672>-&gt;</span>ar_service,
</span></span><span style=display:flex><span>	req<span style=color:#f92672>-&gt;</span>ar_request, <span style=color:#f92672>&amp;</span>req<span style=color:#f92672>-&gt;</span>ar_result);
</span></span></code></pre></div><p>The notification mechanism is not perfectly suitable for the present-day high performance application development. Its callbacks are implemented either via POSIX signal handler, or by creating a new waiting thread and running a caller’s callback function on it.</p><p>The only <a href=https://github.com/pgbouncer/pgbouncer/blob/866d55f9cea996b883de8799c08c9dacf7ee65be/src/dnslookup.c#L309 target=_blank rel=noopener>user</a> I could find on github is <code>pgbouncer</code> (lightweight connection pooler for PostgreSQL):</p><h2 id=72--c-ares-library>7.2 <code>c-ares</code> library
<a class=anchor href=#72--c-ares-library>#</a></h2><p>It should now be clear that neither <code>getaddrinfo()</code> nor <code>getaddrinfo_a()</code> can meet all the needs of modern software development, where asynchronous and non-blocking code is an essential building block. Such code enables great performance by wisely utilizing system resources. This is why the <a href=https://un.curl.dev/mine/c-ares target=_blank rel=noopener>curl developers forked</a> the <code>ares</code> library some time ago and continue to maintain an advanced stub resolver framework called <code><a href=https://c-ares.org/ target=_blank rel=noopener>c-ares</a></code>.</p><blockquote><p><code>c-ares</code> is a modern DNS (stub) resolver library, written in C. It provides interfaces for asynchronous queries while trying to abstract the intricacies of the underlying DNS protocol. It was originally intended for applications which need to perform DNS queries without blocking, or need to perform multiple DNS queries in parallel.</p></blockquote><p><code>c-ares</code> likely has the most features of any alternative stub resolver library I’ve encountered. The list of supported RFCs is massive and comprehensive.</p><p>Unlike other resolvers, <code>c-ares</code> doesn’t use signals for notifications nor does it spawn threads to resolve domain names. Instead, it leverages non-blocking sockets and the <code>epoll</code> (<code><a href=https://man7.org/linux/man-pages/man7/epoll.7.html target=_blank rel=noopener>man 7 epoll</a></code>) syscall on Linux. This makes it an ideal candidate for integration into other <code>epoll</code>-based modern programs.</p><p>Some of the most significant users of c-ares include <code>curl</code>, <code>NodeJS</code>, and <code>Envoy</code>.</p><blockquote class="book-hint warning"><code>c-ares</code>, like <code>getaddrinfo()</code>, uses <code>getenv()</code>, which could potentially lead to a segmentation fault in a multithreaded environment if there is a concurrent <code>setenv()</code> call."</blockquote><h3 id=721-essentials>7.2.1 Essentials
<a class=anchor href=#721-essentials>#</a></h3><p>The configuration step happening during the initialization process of a communications channel (<code><a href=https://c-ares.org/docs/ares_init_options.html target=_blank rel=noopener>ares_init_options</a></code>) allows to change the basic resolver behavior. Here are some important options that could divergence from the <code>glibc</code> <code>getaddrinfo()</code>:</p><ul><li><code>ARES_FLAG_NOSEARCH</code> – don’t use the <code>search</code> domain from <code>/etc/resolv.conf</code> and always ask a nameserver as is.</li><li><code>ARES_OPT_TIMEOUTMS</code>, <code>ARES_OPT_TRIES</code>, <code>ARES_OPT_DOMAINS</code> which overwrite the settings from <code>/etc/resolv.conf</code>.</li><li><code>ARES_OPT_RESOLVCONF</code>, <code>ARES_OPT_HOSTS_FILE</code> – alternative paths for <code>/etc/resolv.conf</code> and <code>/etc/hosts</code>.</li><li><code>ARES_OPT_SERVER_FAILOVER</code> – an equivalent of <code>rotate</code> option from <code>/etc/resolv.conf</code>.</li></ul><p>This is just a small compatibility gist with <code>/etc/resolv.conf</code> and <code>libc</code> <code>getaddrinfo()</code>, but the <a href=https://c-ares.org/docs/ares_init_options.html target=_blank rel=noopener>full list </a>of options contains much more settings.</p><p>The resolve functions are:</p><ul><li><code><a href=https://c-ares.org/docs/ares_gethostbyname.html target=_blank rel=noopener>ares_gethostbyname()</a></code> – an alternative for <code>gethostbyname()</code>(it’s not deprecated);</li><li><code><a href=https://c-ares.org/docs/ares_getaddrinfo.html target=_blank rel=noopener>ares_getaddrinfo()</a></code> – an equivalent for <code>getaddrinfo()</code>.</li></ul><blockquote class="book-hint warning">Version <a href=https://github.com/c-ares/c-ares/releases/tag/cares-1_28_0 target=_blank rel=noopener>1.28.0</a> of <code>c-ares</code> made a significant <a href=https://github.com/c-ares/c-ares/commit/a2a8578ee095225d941e397a635977f69803a6d3#diff-9a06d456d3b73c9eb1022f1fffa7ba92764b58f02605b1771293640a9160ce3d target=_blank rel=noopener>change</a> in how it reads system configuration files. This is important to mention because Ubuntu 24.04 LTS includes <code>c-ares</code> version <strong>1.27</strong> in its repository. Therefore, in this chapter, we will be using version <strong>1.27</strong>.</blockquote><p>The default <code>c-ares</code> initialization process for resolving order is a bit different from the <code>glibc</code> <code>getaddrinfo()</code>.</p><img alt="c-ares init process of reading default sources." src=../images/c-areas-1.27.png width=50% class=img-center><div class=text-center>Figure 4. – <code>c-ares</code> 1.27 init process of reading default sources.</div><p>① – at first it reads <code>/etc/nsswitch.conf</code> to determine the order of sources. It only supports <code>files</code>, <code>dns</code> and <code>resolve</code> (<code>systemd-resolved</code>, we will touch it later in the series).</p><p>② – if <code>/etc/host.conf</code> exists, overwrite the order with its content. This is important to know because if your distribution of GNU/Linux still has the <code>/etc/host.conf</code> (<code><a href=https://man7.org/linux/man-pages/man5/host.conf.5.html target=_blank rel=noopener>man 5 host.conf</a></code>) file it could cost you some time to troubleshoot this behavior.</p><p>③ – if <code>/etc/svc.conf</code> exists, overwrite the order with its content.</p><blockquote class="book-hint warning">This behavior changed in version <a href=https://github.com/c-ares/c-ares/commit/a2a8578ee095225d941e397a635977f69803a6d3#diff-9a06d456d3b73c9eb1022f1fffa7ba92764b58f02605b1771293640a9160ce3d target=_blank rel=noopener>1.28</a>, where the old deprecated system files <code>/etc/host.conf</code> and <code>/etc/svc.conf</code> were dropped."</blockquote><p>Let’s finally write an example with <code>c-ares</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* Example from https://c-ares.org/docs.html */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ares.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/* Callback that is called when DNS query is finished */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addrinfo_cb</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>arg, <span style=color:#66d9ef>int</span> status, <span style=color:#66d9ef>int</span> timeouts,
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>struct</span> ares_addrinfo <span style=color:#f92672>*</span>result)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>void</span>)arg; <span style=color:#75715e>/* Example does not use user context */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Result: %s, timeouts: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>ares_strerror</span>(status), timeouts);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (result) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> ares_addrinfo_node <span style=color:#f92672>*</span>node;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (node <span style=color:#f92672>=</span> result<span style=color:#f92672>-&gt;</span>nodes; node <span style=color:#f92672>!=</span> NULL; node <span style=color:#f92672>=</span> node<span style=color:#f92672>-&gt;</span>ai_next) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>char</span>        addr_buf[<span style=color:#ae81ff>64</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr          <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>ai_family <span style=color:#f92672>==</span> AF_INET) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>in_addr <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr_in <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)node<span style=color:#f92672>-&gt;</span>ai_addr);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>in_addr<span style=color:#f92672>-&gt;</span>sin_addr;
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (node<span style=color:#f92672>-&gt;</span>ai_family <span style=color:#f92672>==</span> AF_INET6) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr_in6 <span style=color:#f92672>*</span>in_addr <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr_in6 <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>)node<span style=color:#f92672>-&gt;</span>ai_addr);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>in_addr<span style=color:#f92672>-&gt;</span>sin6_addr;
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>ares_inet_ntop</span>(node<span style=color:#f92672>-&gt;</span>ai_family, ptr, addr_buf, <span style=color:#66d9ef>sizeof</span>(addr_buf));
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Addr: %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, addr_buf);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ares_freeaddrinfo</span>(result);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>ares_channel_t</span>            <span style=color:#f92672>*</span>channel <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> ares_options        options;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span>                        optmask <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> ares_addrinfo_hints hints;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>!=</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Usage: %s domain</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, argv[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Initialize library */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ares_library_init</span>(ARES_LIB_INIT_ALL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>ares_threadsafety</span>()) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;c-ares not compiled with thread support</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Enable event thread so we don&#39;t have to monitor file descriptors */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>options, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(options));
</span></span><span style=display:flex><span>  optmask      <span style=color:#f92672>|=</span> ARES_OPT_EVENT_THREAD;
</span></span><span style=display:flex><span>  options.evsys <span style=color:#f92672>=</span> ARES_EVSYS_DEFAULT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Initialize channel to run queries, a single channel can accept unlimited
</span></span></span><span style=display:flex><span><span style=color:#75715e>   * queries */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ares_init_options</span>(<span style=color:#f92672>&amp;</span>channel, <span style=color:#f92672>&amp;</span>options, optmask) <span style=color:#f92672>!=</span> ARES_SUCCESS) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;c-ares initialization issue</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Perform an IPv4 and IPv6 request for the provided domain name */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>hints, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(hints));
</span></span><span style=display:flex><span>  hints.ai_family <span style=color:#f92672>=</span> AF_UNSPEC;
</span></span><span style=display:flex><span>  hints.ai_flags  <span style=color:#f92672>=</span> ARES_AI_CANONNAME;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ares_getaddrinfo</span>(channel, argv[<span style=color:#ae81ff>1</span>], NULL, <span style=color:#f92672>&amp;</span>hints, addrinfo_cb,
</span></span><span style=display:flex><span>                   NULL <span style=color:#75715e>/* user context not specified */</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Wait until no more requests are left to be processed */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ares_queue_wait_empty</span>(channel, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* Cleanup */</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ares_destroy</span>(channel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>ares_library_cleanup</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Install dependencies:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo apt install libc-ares-dev
</span></span><span style=display:flex><span>$ <span style=color:#75715e># I use aarch64 if you&#39;re not please change it</span>
</span></span><span style=display:flex><span>$ gcc -L/usr/lib/aarch64-linux-gnu/ -I/usr/lib ./resolver.c -o resolver -lcares
</span></span></code></pre></div><p>If we run it with <code>strace</code>, we can see all the above config files in the output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ strace -e openat ./resolver micrisoft.com
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;/etc/ld.so.cache&#34;</span>, O_RDONLY|O_CLOEXEC<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;/lib/aarch64-linux-gnu/libcares.so.2&#34;</span>, O_RDONLY|O_CLOEXEC<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;/lib/aarch64-linux-gnu/libc.so.6&#34;</span>, O_RDONLY|O_CLOEXEC<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;/etc/resolv.conf&#34;</span>, O_RDONLY<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;/etc/nsswitch.conf&#34;</span>, O_RDONLY<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;/etc/host.conf&#34;</span>, O_RDONLY<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;/etc/svc.conf&#34;</span>, O_RDONLY<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> -1 ENOENT <span style=color:#f92672>(</span>No such file or directory<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>As you can see my cloud image of Ubuntu 24.04 has <code>/etc/host.conf</code> file:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /etc/host.conf
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># The &#34;order&#34; line is only used by old versions of the C library.</span>
</span></span><span style=display:flex><span>order files bind
</span></span><span style=display:flex><span>multi on
</span></span></code></pre></div><p>Another important observation from the <code>strace</code> output is there is no <code>/etc/gai.conf</code>. So there is no way to change the sorting rules by providing a custom policy table.</p><h3 id=721-dual-stack-application>7.2.1 Dual stack application
<a class=anchor href=#721-dual-stack-application>#</a></h3><p>Due to the subtle logic of <code>AI_ADDRCONFIG</code> heuristics<code>,</code>the <code>c-ares</code> developers decided not to bring it.</p><p>Thus if you set <code>AF_UNSPEC</code> flag, two DNS requests for <code>A</code> and <code>AAAA</code> will be sended and two address families will be returned (if of course there is anything to return).</p><p>It is worth mentioning, though, that thanks to <a href=https://datatracker.ietf.org/doc/html/rfc6724 target=_blank rel=noopener>RFC 6724</a>’s sorting algorithm—which includes Rule 2: Prefer matching scope in Section 6—the return order will prefer IPv4 over IPv6 if there are no global scope IPv6 source addresses on the device.</p><p>With IPv6 global scope address on a machine:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./resolver microsoft.com
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Result: Successful completion, timeouts: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Addr: 2603:1030:b:3::152
</span></span><span style=display:flex><span>Addr: 2603:1030:20e:3::23c
</span></span><span style=display:flex><span>Addr: 2603:1030:c02:8::14
</span></span><span style=display:flex><span>Addr: 2603:1020:201:10::10f
</span></span><span style=display:flex><span>Addr: 2603:1010:3:3::5b
</span></span><span style=display:flex><span>Addr: 20.76.201.171
</span></span><span style=display:flex><span>Addr: 20.231.239.246
</span></span><span style=display:flex><span>Addr: 20.70.246.20
</span></span><span style=display:flex><span>Addr: 20.112.250.133
</span></span><span style=display:flex><span>Addr: 20.236.44.162
</span></span></code></pre></div><p>And without:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./resolver microsoft.com
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Result: Successful completion, timeouts: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Addr: 20.70.246.20
</span></span><span style=display:flex><span>Addr: 20.236.44.162
</span></span><span style=display:flex><span>Addr: 20.231.239.246
</span></span><span style=display:flex><span>Addr: 20.76.201.171
</span></span><span style=display:flex><span>Addr: 20.112.250.133
</span></span><span style=display:flex><span>Addr: 2603:1030:c02:8::14
</span></span><span style=display:flex><span>Addr: 2603:1010:3:3::5b
</span></span><span style=display:flex><span>Addr: 2603:1030:b:3::152
</span></span><span style=display:flex><span>Addr: 2603:1020:201:10::10f
</span></span><span style=display:flex><span>Addr: 2603:1030:20e:3::23c
</span></span></code></pre></div><p>Sorting <a href=https://github.com/c-ares/c-ares/blob/2614afc5533848aeeff3fd816794404aa0ecb9fd/src/lib/ares__sortaddrinfo.c#L258-L275 target=_blank rel=noopener>code</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#75715e>/* Rule 2: Prefer matching scope. */</span>
</span></span><span style=display:flex><span>  scope_src1 <span style=color:#f92672>=</span> ARES_IPV6_ADDR_SCOPE_NODELOCAL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (a1<span style=color:#f92672>-&gt;</span>has_src_addr) {
</span></span><span style=display:flex><span>    scope_src1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_scope</span>(<span style=color:#f92672>&amp;</span>a1<span style=color:#f92672>-&gt;</span>src_addr.sa);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  scope_dst1   <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_scope</span>(a1<span style=color:#f92672>-&gt;</span>ai<span style=color:#f92672>-&gt;</span>ai_addr);
</span></span><span style=display:flex><span>  scope_match1 <span style=color:#f92672>=</span> (scope_src1 <span style=color:#f92672>==</span> scope_dst1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  scope_src2 <span style=color:#f92672>=</span> ARES_IPV6_ADDR_SCOPE_NODELOCAL;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (a2<span style=color:#f92672>-&gt;</span>has_src_addr) {
</span></span><span style=display:flex><span>    scope_src2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_scope</span>(<span style=color:#f92672>&amp;</span>a2<span style=color:#f92672>-&gt;</span>src_addr.sa);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  scope_dst2   <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_scope</span>(a2<span style=color:#f92672>-&gt;</span>ai<span style=color:#f92672>-&gt;</span>ai_addr);
</span></span><span style=display:flex><span>  scope_match2 <span style=color:#f92672>=</span> (scope_src2 <span style=color:#f92672>==</span> scope_dst2);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (scope_match1 <span style=color:#f92672>!=</span> scope_match2) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> scope_match2 <span style=color:#f92672>-</span> scope_match1;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>If we run the code under <code>strace</code> with network trace, we see how it performs the same socket calls as <code>getaddrinfo()</code> does in order to retrieve a source address for the destination:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>pid 209162<span style=color:#f92672>]</span> socket<span style=color:#f92672>(</span>AF_INET6, SOCK_DGRAM, IPPROTO_UDP<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>pid 209162<span style=color:#f92672>]</span> connect<span style=color:#f92672>(</span>7, <span style=color:#f92672>{</span>sa_family<span style=color:#f92672>=</span>AF_INET6, sin6_port<span style=color:#f92672>=</span>htons<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>, sin6_flowinfo<span style=color:#f92672>=</span>htonl<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>, inet_pton<span style=color:#f92672>(</span>AF_INET6, <span style=color:#e6db74>&#34;2603:1030:b:3::152&#34;</span>, &amp;sin6_addr<span style=color:#f92672>)</span>, sin6_scope_id<span style=color:#f92672>=</span>0<span style=color:#f92672>}</span>, 28<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>pid 209162<span style=color:#f92672>]</span> getsockname<span style=color:#f92672>(</span>7, <span style=color:#f92672>{</span>sa_family<span style=color:#f92672>=</span>AF_INET6, sin6_port<span style=color:#f92672>=</span>htons<span style=color:#f92672>(</span>54532<span style=color:#f92672>)</span>, sin6_flowinfo<span style=color:#f92672>=</span>htonl<span style=color:#f92672>(</span>0<span style=color:#f92672>)</span>, inet_pton<span style=color:#f92672>(</span>AF_INET6, <span style=color:#e6db74>&#34;fec0::5055:55ff:fe8e:3d07&#34;</span>, &amp;sin6_addr<span style=color:#f92672>)</span>, sin6_scope_id<span style=color:#f92672>=</span>0<span style=color:#f92672>}</span>, <span style=color:#f92672>[</span>28<span style=color:#f92672>])</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>pid 209162<span style=color:#f92672>]</span> close<span style=color:#f92672>(</span>7<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>But notice, if you disable sorting by setting <code>ARES_AI_NOSORT</code> flag in our above code by change <code>hints.ai_flags</code> to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>hints.ai_flags  <span style=color:#f92672>=</span> ARES_AI_NOSORT;
</span></span></code></pre></div><p>it always returns IPv4 addresses first. However, I’m not sure if this order is guaranteed or if it’s due to the order of DNS requests, with the <code>A</code> request being sent before the <code>AAAA</code>. Typically, without network reordering, the answers also arrive in this order.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./resolver microsoft.com
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Result: Successful completion, timeouts: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Addr: 20.231.239.246
</span></span><span style=display:flex><span>Addr: 20.70.246.20
</span></span><span style=display:flex><span>Addr: 20.76.201.171
</span></span><span style=display:flex><span>Addr: 20.112.250.133
</span></span><span style=display:flex><span>Addr: 20.236.44.162
</span></span><span style=display:flex><span>Addr: 2603:1030:c02:8::14
</span></span><span style=display:flex><span>Addr: 2603:1020:201:10::10f
</span></span><span style=display:flex><span>Addr: 2603:1010:3:3::5b
</span></span><span style=display:flex><span>Addr: 2603:1030:b:3::152
</span></span><span style=display:flex><span>Addr: 2603:1030:20e:3::23c
</span></span></code></pre></div><p>Without a fully functional alternative to the <code>AI_ADDRCONFIG</code> flag, using the <code>AF_UNSPEC</code> family can result in unnecessary work if there is no IPv6 routing on the system, as it will still issue <code>AAAA</code> DNS requests. However, these calls could be amortized by the built-in <code>c-ares</code>’ cache. If this isn’t sufficient, you have at least two options, though they add complexity:</p><ol><li><p>Write your own IPv4/IPv6 routable addresses/stack detection.</p></li><li><p>Resolve both families just in case but make per address family DNS calls asynchronously. You can add deadline logic and use the fastest answer with the Happy Eyeballs algorithm. This approach is suggested in <a href=https://datatracker.ietf.org/doc/html/rfc8305#section-3 target=_blank rel=noopener>RFC 8305 Happy Eyeballs Version 2: Better Connectivity Using Concurrency</a>:</p><blockquote><p>Implementations SHOULD NOT wait for both families of answers to return before attempting connection establishment. If one query fails to return or takes significantly longer to return, waiting for the second address family can significantly delay the connection establishment of the first one. Therefore, the client SHOULD treat DNS resolution as asynchronous. Note that if the platform does not offer an asynchronous DNS API, this behavior can be simulated by making two separate synchronous queries on different threads, one per address family.</p></blockquote></li></ol><img alt=c-ares-vs-gettadrinfo src=../images/c-ares-getaddrinfo.png width=70% class=img-center>
<a href=/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/ class="book-btn right-button">Read next chapter →</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#7-async-non-blocking-resolvers-in-c>7. Async non-blocking resolvers in <code>C</code></a><ul><li><a href=#71-getaddrinfo_a>7.1 <code>getaddrinfo_a()</code></a></li><li><a href=#72--c-ares-library>7.2 <code>c-ares</code> library</a><ul><li><a href=#721-essentials>7.2.1 Essentials</a></li><li><a href=#721-dual-stack-application>7.2.1 Dual stack application</a></li></ul></li></ul></li></ul></nav></div></aside></main><div class=cookie-container><p>This website uses "<b>cookies</b>".
Using this website means you're OK with this.
If you are <b>NOT</b>, please close the site page.</p><button class=cookie-btn>
ACCEPT AND CLOSE</button></div><script src=/my_js/cookie.js></script></body></html>