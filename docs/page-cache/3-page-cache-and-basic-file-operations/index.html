<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Page Cache and basic file operations # Now it&rsquo;s time to roll up our sleeves and get started with some practical examples. By the end of this chapter you will know how to interact with Page Cache and which tools you can use.
Utils needed for this section:
sync (man 1 sync) – a tool to flush all dirty pages to persistent storage; /proc/sys/vm/drop_caches (man 5 proc) – a kernel procfs file to trigger Page Cache clearance; vmtouch – a tool for getting Page Cache info about a particular file by its path."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Page Cache and basic file operations"><meta property="og:description" content="Page Cache and basic file operations # Now it&rsquo;s time to roll up our sleeves and get started with some practical examples. By the end of this chapter you will know how to interact with Page Cache and which tools you can use.
Utils needed for this section:
sync (man 1 sync) – a tool to flush all dirty pages to persistent storage; /proc/sys/vm/drop_caches (man 5 proc) – a kernel procfs file to trigger Page Cache clearance; vmtouch – a tool for getting Page Cache info about a particular file by its path."><meta property="og:type" content="article"><meta property="og:url" content="https://biriukov.dev/docs/page-cache/3-page-cache-and-basic-file-operations/"><meta property="article:section" content="docs"><title>Page Cache and basic file operations | Viacheslav Biriukov</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.2dc2f975dfcd8c31592d4a82a46f3d2547e84fa388943d68f713c18e085ecc00.js integrity="sha256-LcL5dd/NjDFZLUqCpG89JUfoT6OIlD1o9xPBjghezAA=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-599VSLESJL")</script><link rel=stylesheet href=/my_css/cookie.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Viacheslav Biriukov</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Linux Page Cache series</span><ul><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>0. Linux Page Cache for SRE</a></li><li><a href=/docs/page-cache/1-prepare-environment-for-experiments/>1. Prepare environments</a></li><li><a href=/docs/page-cache/2-essential-page-cache-theory/>2. Essential theory</a></li><li><a href=/docs/page-cache/3-page-cache-and-basic-file-operations/ class=active>3. Basic file operations</a></li><li><a href=/docs/page-cache/4-page-cache-eviction-and-page-reclaim/>4. Eviction and page reclaim</a></li><li><a href=/docs/page-cache/5-more-about-mmap-file-access/>5. More about mmap()</a></li><li><a href=/docs/page-cache/6-cgroup-v2-and-page-cache/>6. Cgroup v2</a></li><li><a href=/docs/page-cache/7-how-much-memory-my-program-uses-or-the-tale-of-working-set-size/>7. Unique set and working set</a></li><li><a href=/docs/page-cache/8-direct-io-dio/>8. Direct IO</a></li><li><a href=/docs/page-cache/9-advanced-page-cache-observability-and-troubleshooting-tools/>9. Advanced tools</a></li></ul></li></ul><div style=margin-top:30px;margin-bottom:30px><b>More post series:</b><ul><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons>1. File descriptors, pipes, terminals, user sessions, process groups and daemons <span style="padding:0 2px;border-radius:2px;background-color:#e84118;color:#f0f8ff">new</span></li><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>2. Linux Page Cache mini book</li></ul></div><ul><li><a href=https://twitter.com/brk0v/ target=_blank rel=noopener><i class="bi bi-twitter"></i>
Twitter</a></li><li><a href=https://github.com/brk0v/ target=_blank rel=noopener><i class="bi bi-github"></i>
Github</a></li><li><a href=https://www.linkedin.com/in/biriukov/ target=_blank rel=noopener><i class="bi bi-linkedin"></i>
Linkedin</a></li></ul><div style=margin-top:30px><p xmlns:cc=http://creativecommons.org/ns#>This content is licensed under
<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-NC 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"></a></p></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Page Cache and basic file operations</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#page-cache-and-basic-file-operations>Page Cache and basic file operations</a><ul><li><a href=#file-reads>File reads</a><ul><li><a href=#reading-files-with-read-syscall>Reading files with <code>read()</code> syscall</a></li><li><a href=#reading-files-with-mmap-syscall>Reading files with <code>mmap()</code> syscall</a></li></ul></li><li><a href=#file-writes>File writes</a><ul><li><a href=#writing-to-files-with-write-syscall>Writing to files with <code>write()</code> syscall</a></li><li><a href=#file-writes-with-mmap--syscall>File writes with <code>mmap()</code> syscall</a></li><li><a href=#dirty-pages>Dirty pages</a></li><li><a href=#synchronize-file-changes-with-fsync-fdatasync-and-msync>Synchronize file changes with <code>fsync()</code>, <code>fdatasync()</code> and <code>msync()</code></a></li></ul></li><li><a href=#checking-file-presence-in-page-cache-with-mincore>Checking file presence in Page Cache with <code>mincore()</code></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=page-cache-and-basic-file-operations>Page Cache and basic file operations
<a class=anchor href=#page-cache-and-basic-file-operations>#</a></h1><p>Now it&rsquo;s time to roll up our sleeves and get started with some practical examples. By the end of this chapter you will know how to interact with Page Cache and which tools you can use.</p><p>Utils needed for this section:</p><ul><li><code>sync</code> (<code>man 1 sync</code>) – a tool to flush all dirty pages to persistent storage;</li><li><code>/proc/sys/vm/drop_caches</code> (<code>man 5 proc</code>) – a kernel <code>procfs</code> file to trigger Page Cache clearance;</li><li><code>vmtouch</code> – a tool for getting Page Cache info about a particular file by its path.</li></ul><blockquote class="book-hint info"><strong>NOTE</strong>
For now we ignore how <code>vmtouch</code> works. I&rsquo;m showing how to write an alternative with almost all its features later.</blockquote><h2 id=file-reads>File reads
<a class=anchor href=#file-reads>#</a></h2><h3 id=reading-files-with-read-syscall>Reading files with <code>read()</code> syscall
<a class=anchor href=#reading-files-with-read-syscall>#</a></h3><p>I start with a simple program that reads the first 2 bytes from our test file <code>/var/tmp/file1.db</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;br&#34;</span>) <span style=color:#66d9ef>as</span> f:  
</span></span><span style=display:flex><span>    print(f<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>2</span>))
</span></span></code></pre></div><p>Usually this kind of read requests are translated into the <code>read()</code> syscall. Let&rsquo;s run the script with <code>strace</code> to make sure that <code>f.read()</code> uses <code>read()</code> syscall:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ strace -s0 python3 ./read_2_bytes.py
</span></span></code></pre></div><p>The output should look something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>...
</span></span><span style=display:flex><span>openat<span style=color:#f92672>(</span>AT_FDCWD, <span style=color:#e6db74>&#34;./file1.db&#34;</span>, O_RDONLY|O_CLOEXEC<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>read<span style=color:#f92672>(</span>3, <span style=color:#e6db74>&#34;%B\353\276\0053\356\346Nfy2\354[&amp;\357\300\260%D6</span>$b<span style=color:#e6db74>?&#39;\31\237_fXD\234&#34;</span>..., 4096<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>4096</span>  
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><blockquote class="book-hint info"><p><strong>NOTE</strong></p><p>The <code>read()</code> syscall returned 4096 bytes (one page) even thought the script asked only for 2 bytes. It&rsquo;s an example of python optimizations and internal buffered IO. Although this is beyond the scope of this post, but in some cases it is important to keep this in mind.</p></blockquote><p>Now let’s check how much data kernel&rsquo;s cached. In order to get this info we use <code>vmtouch</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>       LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>          ⬇
</span></span><span style=display:flex><span>  Resident Pages: 20/32768  80K/128M  0.061%  
</span></span><span style=display:flex><span>         Elapsed: 0.001188 seconds
</span></span></code></pre></div><p>From the output we can see that instead of 2B of data which python&rsquo;s asked, the kernel has cached 80KiB or 20 pages.</p><p>By design kernel can&rsquo;t load anything less that 4KiB or one page into Page Cache, but what about other 19 pages? This is a good example of kernel&rsquo;s read ahead logic and its preference to perform sequential IO operations over random. The basic idea is to predict the subsequent reads and minimize the number of disk seeks. This behavior can be controlled by syscalls: <code>posix_fadvise()</code> (<code>man 2 posix_fadvise</code>) and <code>readahead()</code> (<code>man 2 readahead</code>).</p><blockquote class="book-hint info"><p><strong>NOTE</strong></p><p>Usually, in a production environment, it doesn’t make a big difference for database management systems and storages to tune the default read-ahead parameters. If DBMS doesn&rsquo;t need data which were cached by the read-ahead, the kernel memory reclaim policy should eventually evict these pages from Page Cache. And usually, the sequential IO are not expensive for kernel and hardware. Disabling read-ahead at all might even lead to some performance degradations due to increased number of disk IO operations in the kernel queues, more context switches and more time for kernel memory management subsystem to recognize the working set. We will talk about memory reclaiming policy, memory pressure and cache writeback later in this series.</p></blockquote><p>Let’s now use <code>posix_fadvise()</code> to notify kernel that we are reading the file randomly and thus we don&rsquo;t want to have any read ahead features:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;br&#34;</span>) <span style=color:#66d9ef>as</span> f:  
</span></span><span style=display:flex><span>    fd <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>fileno()  
</span></span><span style=display:flex><span>    os<span style=color:#f92672>.</span>posix_fadvise(fd, <span style=color:#ae81ff>0</span>, os<span style=color:#f92672>.</span>fstat(fd)<span style=color:#f92672>.</span>st_size, os<span style=color:#f92672>.</span>POSIX_FADV_RANDOM)  
</span></span><span style=display:flex><span>    print(f<span style=color:#f92672>.</span>read(<span style=color:#ae81ff>2</span>))
</span></span></code></pre></div><p>Before running the script we need to drop all caches:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#ae81ff>3</span> | sudo tee /proc/sys/vm/drop_caches <span style=color:#f92672>&amp;&amp;</span> python3 ./read_2_random.py
</span></span></code></pre></div><p>And now if you check the <code>vmtouch</code> output you can see that there is only one page as expected:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>     LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>        ⬇
</span></span><span style=display:flex><span>  Resident Pages: 1/32768  4K/128M  0.00305%
</span></span><span style=display:flex><span>         Elapsed: 0.001034 seconds
</span></span></code></pre></div><h3 id=reading-files-with-mmap-syscall>Reading files with <code>mmap()</code> syscall
<a class=anchor href=#reading-files-with-mmap-syscall>#</a></h3><p>For reading data from files we can also use <code>mmap()</code> syscall (<code>man 2 mmap</code>). <code>mmap()</code> is a &ldquo;magic&rdquo; tool and can be used to solve a wide range of tasks. But for our tests we need only one its feature – an ability to map a file into a process&rsquo; memory in order to access the file as a flat array. I&rsquo;m taking about <code>mmap()</code> in more detail later. But at the moment, if you are not familiar with it, <code>mmap()</code> API should be clear from the following example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> mmap
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> mmap<span style=color:#f92672>.</span>mmap(f<span style=color:#f92672>.</span>fileno(), <span style=color:#ae81ff>0</span>, prot<span style=color:#f92672>=</span>mmap<span style=color:#f92672>.</span>PROT_READ) <span style=color:#66d9ef>as</span> mm:
</span></span><span style=display:flex><span>        print(mm[:<span style=color:#ae81ff>2</span>])
</span></span></code></pre></div><p>The above code do the same as we&rsquo;ve just done with <code>read()</code> syscall. It reads the first 2 bytes of the file.</p><p>Also for test purposes, we need to flush all caches before the script should be executed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#ae81ff>3</span> | sudo tee /proc/sys/vm/drop_caches <span style=color:#f92672>&amp;&amp;</span> python3 ./read_2_mmap.py
</span></span></code></pre></div><p>And checking the Page Cache content:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>           Files: 1.       LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>           ⬇
</span></span><span style=display:flex><span>  Resident Pages: 1024/32768  4M/128M  3.12%
</span></span><span style=display:flex><span>         Elapsed: 0.000627 seconds
</span></span></code></pre></div><p>As you can see <code>mmap()</code> has performed even more aggressive readahead.</p><p>Let&rsquo;s change the readahead with <code>madvise()</code> syscall like we did with <code>fadvise()</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> mmap
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> mmap<span style=color:#f92672>.</span>mmap(f<span style=color:#f92672>.</span>fileno(), <span style=color:#ae81ff>0</span>, prot<span style=color:#f92672>=</span>mmap<span style=color:#f92672>.</span>PROT_READ) <span style=color:#66d9ef>as</span> mm:
</span></span><span style=display:flex><span>        mm<span style=color:#f92672>.</span>madvise(mmap<span style=color:#f92672>.</span>MADV_RANDOM)
</span></span><span style=display:flex><span>        print(mm[:<span style=color:#ae81ff>2</span>])
</span></span></code></pre></div><p>Run it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ echo <span style=color:#ae81ff>3</span> | sudo tee /proc/sys/vm/drop_caches <span style=color:#f92672>&amp;&amp;</span> python3 ./read_2_mmap_random.py
</span></span></code></pre></div><p>and Page Cache content:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>     LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>        ⬇
</span></span><span style=display:flex><span>  Resident Pages: 1/32768  4K/128M  0.00305% 
</span></span><span style=display:flex><span>         Elapsed: 0.001077 seconds
</span></span></code></pre></div><p>As you can see from the above output, with the <code>MADV_RANDOM</code> flag we managed to achieve the exactly one page read from disk and thus one page in Page Cache.</p><h2 id=file-writes>File writes
<a class=anchor href=#file-writes>#</a></h2><p>Now let&rsquo;t play with writes.</p><h3 id=writing-to-files-with-write-syscall>Writing to files with <code>write()</code> syscall
<a class=anchor href=#writing-to-files-with-write-syscall>#</a></h3><p>Let’s continue working with our experimental file and try to update the first 2 bytes instead:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;br+&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    print(f<span style=color:#f92672>.</span>write(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;ab&#34;</span>))
</span></span></code></pre></div><blockquote class="book-hint warning"><p><strong>NOTE</strong></p><p>Be careful and don&rsquo;t open a file with <code>w</code> mode. It will rewrite your file with 2 byte. We need <code>r+</code> mode.</p></blockquote><p>Drop all caches and run the above script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sync; echo <span style=color:#ae81ff>3</span> | sudo tee /proc/sys/vm/drop_caches <span style=color:#f92672>&amp;&amp;</span> python3 ./write_2_bytes.py
</span></span></code></pre></div><p>Now let&rsquo;s check the content of the Page Cache.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db
</span></span><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>     LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>        ⬇
</span></span><span style=display:flex><span>  Resident Pages: 1/32768  4K/128M  0.00305%
</span></span><span style=display:flex><span>         Elapsed: 0.000674 seconds
</span></span></code></pre></div><p>As you can see we have 1 page cached after only 2B write. It&rsquo;s an important observation because <strong>if your writes are smaller than a page size, you will have 4KiB reads before your writes</strong> in order to populate Page Cache.</p><p>Also we can check dirty pages by reading the current cgroup memory stat file.</p><p>Get a current terminal cgroup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/self/cgroup
</span></span><span style=display:flex><span>0::/user.slice/user-1000.slice/session-4.scope
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ grep dirty /sys/fs/cgroup/user.slice/user-1000.slice/session-3.scope/memory.stat  
</span></span><span style=display:flex><span>file_dirty <span style=color:#ae81ff>4096</span>
</span></span></code></pre></div><p>If you see 0, run the script one more time, you apparently get lucky and the dirty pages have already been written to disk.</p><h3 id=file-writes-with-mmap--syscall>File writes with <code>mmap()</code> syscall
<a class=anchor href=#file-writes-with-mmap--syscall>#</a></h3><p>Le&rsquo;t now replicate the write with <code>mmap()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> mmap
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;r+b&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> mmap<span style=color:#f92672>.</span>mmap(f<span style=color:#f92672>.</span>fileno(), <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>as</span> mm:
</span></span><span style=display:flex><span>        mm[:<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;ab&#34;</span>
</span></span></code></pre></div><p>You can repeat the above commands with <code>vmtouch</code> and cgroup <code>grep</code> to get dirty pages, and should get the same output. The only one exception is the read ahead policy. By default <code>mmap()</code> loads much more data in Page Cache even for write requests.</p><h3 id=dirty-pages>Dirty pages
<a class=anchor href=#dirty-pages>#</a></h3><p>As we saw earlier, a process generates dirty pages by writing to files through Page Cache.</p><p>Linux provides several options to get the amount of dirty pages. The first and the oldest one is to read <code>/proc/memstat</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/meminfo | grep Dirty
</span></span><span style=display:flex><span>Dirty:                 <span style=color:#ae81ff>4</span> kB
</span></span></code></pre></div><p>Often the entire system information is hard to interpret and use because we can&rsquo;t determine which process and which file has these dirty pages.</p><p>That&rsquo;s why the best option in order to get dirty page info is to use cgroup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /sys/fs/cgroup/user.slice/user-1000.slice/session-3.scope/memory.stat  | grep dirt
</span></span><span style=display:flex><span>file_dirty <span style=color:#ae81ff>4096</span>
</span></span></code></pre></div><p>If your program uses <code>mmap()</code> to write to files, you have one more option to get dirty pages stats with a per process granularity. <code>procfs</code> has the <code>/proc/PID/smaps</code> file. It contains memory counters for the process broken down by virtual memory areas (VMA). With <code>mmap()</code> process has the VMA mapped to the file and corresponding info. We can get dirty pages by finding:</p><ul><li><code>Private_Dirty</code> – the amount of dirty data this process generated;</li><li><code>Shared_Dirty</code> – and the amount other processes wrote. This metric shows data only for referenced pages. This means the process should access pages and keep them in its <a href=https://en.wikipedia.org/wiki/Page_table target=_blank rel=noopener>page table</a> (more details later).</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/578097/smaps | grep file1.db -A <span style=color:#ae81ff>12</span> | grep Dirty
</span></span><span style=display:flex><span>Shared_Dirty:          <span style=color:#ae81ff>0</span> kB
</span></span><span style=display:flex><span>Private_Dirty:       <span style=color:#ae81ff>736</span> kB
</span></span></code></pre></div><p>But what if we want to get the dirty page stats for a file. To answer this question linux kernel provides <a href=https://www.kernel.org/doc/Documentation/vm/pagemap.txt target=_blank rel=noopener>2 files</a> in <code>procfs</code>: <code>/proc/PID/pagemap</code> and <code>/proc/kpageflags</code>. I&rsquo;m showing how to write our own tool with them later in the series, but for now we can use the debug tool from the linux kernel repo to get per file page info: <a href=https://github.com/torvalds/linux/blob/master/tools/vm/page-types.c target=_blank rel=noopener><code>page-types</code></a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo page-types -f /var/tmp/file1.db -b dirty
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>             flags      page-count       MB  symbolic-flags                     long-symbolic-flags
</span></span><span style=display:flex><span>0x0000000000000838             <span style=color:#ae81ff>267</span>        <span style=color:#ae81ff>1</span>  ___UDl_____M________________________________       uptodate,dirty,lru,mmap
</span></span><span style=display:flex><span>0x000000000000083c              <span style=color:#ae81ff>20</span>        <span style=color:#ae81ff>0</span>  __RUDl_____M________________________________       referenced,uptodate,dirty,lru,mmap
</span></span><span style=display:flex><span>             total             <span style=color:#ae81ff>287</span>        <span style=color:#ae81ff>1</span>
</span></span></code></pre></div><p>I filtered out all pages of our file <code>/var/tmp/file1.db</code> by the <code>dirty</code> flag. In the output you can see that the file has 287 dirty pages or 1 MiB of dirty data which will be persisted to storage eventually. <code>page-type</code> aggregates pages by flags, so you can see 2 sets in the output. Both have the dirty flag <code>D</code> and the difference between them is the presence of the referenced flag <code>R</code> (which I&rsquo;m briefly touching in the Page Cache eviction section later).</p><h3 id=synchronize-file-changes-with-fsync-fdatasync-and-msync>Synchronize file changes with <code>fsync()</code>, <code>fdatasync()</code> and <code>msync()</code>
<a class=anchor href=#synchronize-file-changes-with-fsync-fdatasync-and-msync>#</a></h3><p>We already used <code>sync</code> (<code>man 1 sync</code>) to flush all dirty pages to disks before every test to get a fresh system without any interferences. But what if we want to write a database management system and we need to be sure that all writes will get to disks before a power outage or other hardware errors occur. For such cases linux provides several methods to force kernel to run sync of pages for the file in Page Cache:</p><ul><li><code>fsync()</code> – blocks until all dirty pages of the target file and its metadata are synced;</li><li><code>fdatasync()</code> – the same as the above but excluding metadata;</li><li><code>msync()</code> – the same as the <code>fsync()</code> but for memory mapped file;</li><li>open a file with <code>O_SYNC</code> or <code>O_DSYNC</code> flags to make all file writes synchronous by default and work as a corresponding <code>fsync()</code> and <code>fdatasync()</code> syscalls accordingly.</li></ul><blockquote class="book-hint info"><p><strong>NOTE</strong></p><p>You still need to care about write berries and understand how the underlying file system works, because write operations might be reordered by the kernel scheduler. Usually a file append operation is safe and can&rsquo;t corrupt the previous written data. Other types of mutate operations may mess with your files (for instance, for ext4, even with the default journal). That&rsquo;s why all database management systems like MongoDB, PostgreSQL, Etcd, Dgraph, etc have a write ahead logs (WAL) which are append only. If you&rsquo;re curious more about this topic, this <a href=https://dgraph.io/blog/post/alice/ target=_blank rel=noopener>blog post from Dgraph</a> is a good starting point.</p></blockquote><p>And here is an example of the file sync:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;br+&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    fd <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>fileno()
</span></span><span style=display:flex><span>    os<span style=color:#f92672>.</span>fsync(fd)
</span></span></code></pre></div><h2 id=checking-file-presence-in-page-cache-with-mincore>Checking file presence in Page Cache with <code>mincore()</code>
<a class=anchor href=#checking-file-presence-in-page-cache-with-mincore>#</a></h2><p>Before we go any further, let’s figure out how <code>vmtouch</code> manages to show us how many pages of a target file Page Cache contains.</p><p>The secret is a <code>mincore()</code> syscall (<code>man 2 mincore</code>). <code>mincore()</code> stands for &ldquo;memory in core&rdquo;. Its parameters are a starting virtual memory address, a length of the address space and a resulting vector. <code>mincore()</code> works with memory (not files), so as it can be used for checking if anonymous memory was swapped out.</p><blockquote><p><code>man 2 mincore</code></p><p><code>mincore()</code> returns a vector that indicates whether pages of the calling process&rsquo;s virtual memory are resident in core (RAM), and so will not cause a disk access (pagefault) if referenced. The kernel returns residency information about the pages starting at the address addr, and continuing for length bytes.</p></blockquote><p>So to replicate <code>vmtouch</code> we need to map a file into the virtual memory of the process, even thought we are not going to make neither reads nor writes. We just want to have it in the process&rsquo; memory area (more about this later in <code>mmap()</code> section).</p><p>Now we have all we need to write our own simple <code>vmtouch</code> in order to show cached pages by file path. I&rsquo;m using Go here, because unfortunately, Python doesn&rsquo;t have an easy way to call <code>mincore()</code> syscall:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;syscall&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageSize</span> = int64(<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Getpagesize</span>())
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mode</span>     = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>FileMode</span>(<span style=color:#ae81ff>0600</span>)
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>path</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>OpenFile</span>(<span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>O_RDONLY</span>|<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>O_NOFOLLOW</span>|<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>O_NOATIME</span>, <span style=color:#a6e22e>mode</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>stat</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Lstat</span>(<span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stat</span>.<span style=color:#a6e22e>Size</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pages</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>pageSize</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mm</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Mmap</span>(int(<span style=color:#a6e22e>file</span>.<span style=color:#a6e22e>Fd</span>()), <span style=color:#ae81ff>0</span>, int(<span style=color:#a6e22e>size</span>), <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>PROT_READ</span>, <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>MAP_SHARED</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Munmap</span>(<span style=color:#a6e22e>mm</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mmPtr</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mm</span>[<span style=color:#ae81ff>0</span>]))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cached</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>pages</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sizePtr</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>cachedPtr</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>cached</span>[<span style=color:#ae81ff>0</span>]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ret</span>, <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>Syscall</span>(<span style=color:#a6e22e>syscall</span>.<span style=color:#a6e22e>SYS_MINCORE</span>, <span style=color:#a6e22e>mmPtr</span>, <span style=color:#a6e22e>sizePtr</span>, <span style=color:#a6e22e>cachedPtr</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ret</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#e6db74>&#34;syscall SYS_MINCORE failed: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>cached</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// the least significant bit of each byte will be set if the corresponding page 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// is currently resident in memory, and be clear otherwise.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span><span style=color:#f92672>%</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>n</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Resident Pages: %d/%d  %d/%d\n&#34;</span>, <span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>pages</span>, <span style=color:#a6e22e>n</span><span style=color:#f92672>*</span>int(<span style=color:#a6e22e>pageSize</span>), <span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And if we run it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ go run ./main.go
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>Resident Pages: 1024/32768  4194304/134217728
</span></span></code></pre></div><p>And comparing it with <code>vmtouch</code> output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db
</span></span><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>         LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>            ⬇
</span></span><span style=display:flex><span>  Resident Pages: 1024/32768  4M/128M  3.12%
</span></span><span style=display:flex><span>         Elapsed: 0.000804 seconds
</span></span></code></pre></div><a href=/docs/page-cache/4-page-cache-eviction-and-page-reclaim/ class="book-btn right-button">Read next chapter →</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#page-cache-and-basic-file-operations>Page Cache and basic file operations</a><ul><li><a href=#file-reads>File reads</a><ul><li><a href=#reading-files-with-read-syscall>Reading files with <code>read()</code> syscall</a></li><li><a href=#reading-files-with-mmap-syscall>Reading files with <code>mmap()</code> syscall</a></li></ul></li><li><a href=#file-writes>File writes</a><ul><li><a href=#writing-to-files-with-write-syscall>Writing to files with <code>write()</code> syscall</a></li><li><a href=#file-writes-with-mmap--syscall>File writes with <code>mmap()</code> syscall</a></li><li><a href=#dirty-pages>Dirty pages</a></li><li><a href=#synchronize-file-changes-with-fsync-fdatasync-and-msync>Synchronize file changes with <code>fsync()</code>, <code>fdatasync()</code> and <code>msync()</code></a></li></ul></li><li><a href=#checking-file-presence-in-page-cache-with-mincore>Checking file presence in Page Cache with <code>mincore()</code></a></li></ul></li></ul></nav></div></aside></main><div class=cookie-container><p>This website uses "<b>cookies</b>".
Using this website means you're OK with this.
If you are <b>NOT</b>, please close the site page.</p><button class=cookie-btn>
ACCEPT AND CLOSE</button></div><script src=/my_js/cookie.js></script></body></html>