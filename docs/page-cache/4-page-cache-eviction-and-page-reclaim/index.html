<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Page Cache eviction and page reclaim # So far, we have talked about adding data to Page Cache by reading and writing files, checking existence of files in the cache and flushing the cache content manually. But the most important part of any cache system is its eviction policy or regarding Linux Page Cache it&rsquo;s also the memory page reclaim policy. Linux Page Cache, like any other cache, continuously monitors the last used pages, makes decisions about which pages should be deleted and which should be kept in the cache."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Page Cache eviction and page reclaim"><meta property="og:description" content="Page Cache eviction and page reclaim # So far, we have talked about adding data to Page Cache by reading and writing files, checking existence of files in the cache and flushing the cache content manually. But the most important part of any cache system is its eviction policy or regarding Linux Page Cache it&rsquo;s also the memory page reclaim policy. Linux Page Cache, like any other cache, continuously monitors the last used pages, makes decisions about which pages should be deleted and which should be kept in the cache."><meta property="og:type" content="article"><meta property="og:url" content="https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim/"><meta property="article:section" content="docs"><title>Page Cache eviction and page reclaim | Viacheslav Biriukov</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.b211122dfb3b7023ace34d23d7e01a74447de25298a1345be5ede2ccca693949.js integrity="sha256-shESLfs7cCOs400j1+AadER94lKYoTRb5e3izMppOUk=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-599VSLESJL")</script><link rel=stylesheet href=/my_css/cookie.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Viacheslav Biriukov</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>Linux Page Cache series</span><ul><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>0. Linux Page Cache for SRE</a></li><li><a href=/docs/page-cache/1-prepare-environment-for-experiments/>1. Prepare environments</a></li><li><a href=/docs/page-cache/2-essential-page-cache-theory/>2. Essential theory</a></li><li><a href=/docs/page-cache/3-page-cache-and-basic-file-operations/>3. Basic file operations</a></li><li><a href=/docs/page-cache/4-page-cache-eviction-and-page-reclaim/ class=active>4. Eviction and page reclaim</a></li><li><a href=/docs/page-cache/5-more-about-mmap-file-access/>5. More about mmap()</a></li><li><a href=/docs/page-cache/6-cgroup-v2-and-page-cache/>6. Cgroup v2</a></li><li><a href=/docs/page-cache/7-how-much-memory-my-program-uses-or-the-tale-of-working-set-size/>7. Unique set and working set</a></li><li><a href=/docs/page-cache/8-direct-io-dio/>8. Direct IO</a></li><li><a href=/docs/page-cache/9-advanced-page-cache-observability-and-troubleshooting-tools/>9. Advanced tools</a></li></ul></li></ul><div style=margin-top:30px;margin-bottom:30px><b>More post series:</b><ul><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons>1. File descriptors, pipes, terminals, user sessions, process groups and daemons <span style="padding:0 2px;border-radius:2px;background-color:#e84118;color:#f0f8ff">new</span></li><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>2. Linux Page Cache mini book</li></ul></div><ul><li><a href=https://twitter.com/brk0v/ target=_blank rel=noopener><i class="bi bi-twitter"></i>
Twitter</a></li><li><a href=https://github.com/brk0v/ target=_blank rel=noopener><i class="bi bi-github"></i>
Github</a></li><li><a href=https://www.linkedin.com/in/biriukov/ target=_blank rel=noopener><i class="bi bi-linkedin"></i>
Linkedin</a></li></ul><div style=margin-top:30px><p xmlns:cc=http://creativecommons.org/ns#>This content is licensed under
<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-NC 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"></a></p></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Page Cache eviction and page reclaim</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#page-cache-eviction-and-page-reclaim>Page Cache eviction and page reclaim</a><ul><li><a href=#theory>Theory</a></li><li><a href=#manual-pages-eviction-with-posix_fadv_dontneed>Manual pages eviction with <code>POSIX_FADV_DONTNEED</code></a></li><li><a href=#make-your-memory-unevictable>Make your memory unevictable</a></li><li><a href=#page-cache-vmswappiness-and-modern-kernels>Page Cache, <code>vm.swappiness</code> and modern kernels</a></li><li><a href=#understanding-memory-reclaim-process-with-procpidpagemap>Understanding memory reclaim process with <code>/proc/pid/pagemap</code></a><ul><li><a href=#page-types-kernel-page-tool><code>page-types</code> kernel page tool</a></li><li><a href=#writing-page-cache-lru-monitor-tool>Writing Page Cache LRU monitor tool</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=page-cache-eviction-and-page-reclaim>Page Cache eviction and page reclaim
<a class=anchor href=#page-cache-eviction-and-page-reclaim>#</a></h1><p>So far, we have talked about adding data to Page Cache by reading and writing files, checking existence of files in the cache and flushing the cache content manually. But the most important part of any cache system is its <em>eviction policy</em> or regarding Linux Page Cache it&rsquo;s also the memory <em>page reclaim</em> policy. Linux Page Cache, like any other cache, continuously monitors the last used pages, makes decisions about which pages should be deleted and which should be kept in the cache.</p><p>The main approach to control and tune Page Cache is the cgroup subsystem. You can divide the memory of the server into a number of smaller caches (cgroups) and thus control and protect applications and services. In addition, the cgroup memory and IO controllers provide a lot of statistics that is useful for tuning your software and understanding the internals of the cache.</p><h2 id=theory>Theory
<a class=anchor href=#theory>#</a></h2><p>Linux Page Cache is closely tighten with Linux Memory Management, cgroup and virtual file system (VFS). So, in order to understand how the eviction works, we need to start with some basic internals of memory reclaim policy. Its core building block is a <strong>per cgroup pair</strong> of <strong>active and inactive lists</strong>:</p><ol><li>the first pair for anonymous memory (for instance, allocated with <code>malloc()</code> or not file backended <code>mmap()</code>);</li><li>the second pair for Page Cache file memory (all file operations including <code>read()</code>, <code>write</code>, file<code>mmap()</code> accesses, etc).</li></ol><p>The former is exactly what we are interested in. This pair is what linux uses for Page Cache evection process. The least recently used algorithm <a href=https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_%28LRU%29 target=_blank rel=noopener>LRU</a> is the core of each list. In turn, these 2 list form a <a href=https://en.wikipedia.org/wiki/Page_replacement_algorithm#Clock target=_blank rel=noopener>double clock</a> data structure. In general, Linux should choose pages that have not been used recently (inactive), based on the fact that the pages that have not been used recently will not be used frequently in a short period of time. This is the basic idea of ​​the LRU algorithm. Both the active and the inactive lists adopt the form of FIFO (First In First Out) for their entries. New elements are added to the head of the linked list, and the elements in between gradually move toward the end. When memory reclamation is needed, the kernel always selects the page at the end of the inactive list for releasing. The following figure shows the simplified concept of the idea:</p><p><img src=../images/lru.png alt="inactive active LRU page cache lists"></p><p>For example, the system starts with the following content of the lists. A user process has just read some data from disks. This action triggered the kernel to load data to the cache. It was the first time when the kernel had to access the file, hence it added a page <code>h</code> to the head of the inactive list of the process&rsquo;s cgroup:</p><p><img src=../images/eviction-1.png alt="Adding a page h to the head of the inactive LRU list"></p><p>Some time has passed, the system loads 2 more pages: <code>i</code> and <code>j</code> to the inactive list and accordingly has to evict pages <code>a</code> and <code>b</code> from it. This action also shifts all pages toward the tail of the inactive LRU list including our page <code>h</code>:</p><p><img src=../images/eviction-2.png alt="Shifting page h toward tail of the inactive LRU list due to adding new i and j pages"></p><p>Now, a new file operation to the page <code>h</code> promotes the page to the active LRU list by putting it at the head. This action also ousts the page <code>1</code> to the head of the inactive LRU list and shifts all other members.</p><p><img src=../images/eviction-3.png alt></p><p>As time flies page <code>h</code> looses its head position in the active LRU list.</p><p><img src=../images/eviction-4.png alt></p><p>But a new file access to the <code>h</code>&rsquo;s position in the file returns <code>h</code> back to the head of the active LRU list.</p><p><img src=../images/eviction-5.png alt></p><p>The above figures show the simplified version of the algorithm.</p><p>But it&rsquo;s worth mentioning, that the real process of pages promotion and demotion is much more complicated and sophisticated.</p><p>First of all, if a system has <a href=https://en.wikipedia.org/wiki/Non-uniform_memory_access target=_blank rel=noopener>NUMA</a> hardware nodes (<code>man 8 numastat</code>), <strong>it has twice more LRU lists</strong>. The reason is that the kernel tries to store memory information in the NUMA nodes in order to have fewer lock contentions.</p><p>In addition, Linux Page Cache also has <strong>special shadow and referenced flag logic</strong> for promotion, demotion and re-promotion pages.</p><p><strong>Shadow entries</strong> help to mitigate <strong>the <a href=https://en.wikipedia.org/wiki/Thrashing_%28computer_science%29 target=_blank rel=noopener>memory thrashing problem</a></strong>. This issue happens when the programs&rsquo; working set size is close to or greater than the real memory size (may be cgroup limit or the system RAM limitation). In such situation the reading pattern may evict pages from the inactive list before the subsequent second read request has appeared. The full idea described in the <a href=https://elixir.bootlin.com/linux/v5.14-rc7/source/mm/workingset.c target=_blank rel=noopener>mm/workingset.c</a> and includes calculating <strong>refault distance</strong>. This distance is used to make a judgment whether to put the page from the shadow entries immediately to the active LRU list or not.</p><p>Another simplification that I made was about <a href=https://elixir.bootlin.com/linux/v5.14.3/source/include/linux/page-flags.h#L105 target=_blank rel=noopener><code>PG_referenced</code></a> page flag. In reality the page promotion and demotion use this flag as an addition input parameter in the decision algorithm. A more correct flow of the page promotion:</p><script src=/mermaid.min.js></script>
<script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"default"})</script><p class=mermaid>flowchart LR
A[Inactive LRU,\nunreferenced] --> B[Inactive LRU,\nreferenced]
B --> C[Active LRU,\nunreferenced]
C --> D[Active LRU,\nreferenced]</p><h2 id=manual-pages-eviction-with-posix_fadv_dontneed>Manual pages eviction with <code>POSIX_FADV_DONTNEED</code>
<a class=anchor href=#manual-pages-eviction-with-posix_fadv_dontneed>#</a></h2><p>I&rsquo;ve shown already how to drop all Page Cache entries using <code>/proc/sys/vm/drop_caches</code> file. But what if we want for some reason to clear the cache for a file?</p><blockquote class="book-hint info"><p><strong>EXAMPLE</strong></p><p>It could be sometimes useful to evict a file from the cache in a real life situation. Assume we want to test how fast our MongoDB gets back to optimal condition after a system reboot. You can stop a replica, clean all its files from Page Cache and start it back.</p></blockquote><p><code>vmtouch</code> already can do that. Its <code>-e</code> flag commands kernel to evict all pages of the requested file from Page Cache:</p><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db -e
</span></span><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>   Evicted Pages: <span style=color:#ae81ff>32768</span> <span style=color:#f92672>(</span>128M<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>         Elapsed: 0.000704 seconds
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db
</span></span><span style=display:flex><span>           Files: 1.    LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>        ⬇
</span></span><span style=display:flex><span>  Resident Pages: 0/32768  0/128M  0% 
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>         Elapsed: 0.000566 seconds
</span></span></code></pre></div><p>Let&rsquo;s look under the hood and figure out how it works. In order to write out own such tool we need to use already seen <code>posix_fadvise</code> syscall with the <code>POSIX_FADV_DONTNEED</code> option.</p><p>Code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;/var/tmp/file1.db&#34;</span>, <span style=color:#e6db74>&#34;br&#34;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>    fd <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>fileno()
</span></span><span style=display:flex><span>    os<span style=color:#f92672>.</span>posix_fadvise(fd, <span style=color:#ae81ff>0</span>, os<span style=color:#f92672>.</span>fstat(fd)<span style=color:#f92672>.</span>st_size, os<span style=color:#f92672>.</span>POSIX_FADV_DONTNEED)
</span></span></code></pre></div><p>For testing, I read the entire test file into Page Cache with <code>dd</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>/var/tmp/file1.db of<span style=color:#f92672>=</span>/dev/null  
</span></span><span style=display:flex><span>262144+0 records in  
</span></span><span style=display:flex><span>262144+0 records out  
</span></span><span style=display:flex><span><span style=color:#ae81ff>134217728</span> bytes <span style=color:#f92672>(</span><span style=color:#ae81ff>134</span> MB, <span style=color:#ae81ff>128</span> MiB<span style=color:#f92672>)</span> copied, 0.652248 s, <span style=color:#ae81ff>206</span> MB/s  
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db  
</span></span><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>         LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>             ⬇
</span></span><span style=display:flex><span>  Resident Pages: 32768/32768  128M/128M  100%
</span></span><span style=display:flex><span>         Elapsed: 0.002719 seconds  
</span></span></code></pre></div><p>And now after running our script we should see 0 pages in Page Cache:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 ./evict_full_file.py  
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ vmtouch /var/tmp/file1.db  
</span></span><span style=display:flex><span>           Files: <span style=color:#ae81ff>1</span>     LOOK HERE
</span></span><span style=display:flex><span>     Directories: <span style=color:#ae81ff>0</span>        ⬇
</span></span><span style=display:flex><span>  Resident Pages: 0/32768  0/128M  0%
</span></span><span style=display:flex><span>         Elapsed: 0.000818 seconds
</span></span></code></pre></div><h2 id=make-your-memory-unevictable>Make your memory unevictable
<a class=anchor href=#make-your-memory-unevictable>#</a></h2><p>But what if you want to force the kernel to keep your file memory in Page Cache, no matter what. This is called making the file memory <strong>unevictable</strong> .</p><blockquote class="book-hint info"><p><strong>EXAMPLE</strong></p><p>Sometimes you have to force the kernel to give you a 100% guarantee that your files will not be evicted from the memory. You can want it even with modern linux kernels and properly configured cgroup limits, which should keep the working data set in Page Cache. For example, due to issues with other processes on the system where you share disk and network IO. Or, for instance, because of an outage of a network attached storage.</p></blockquote><p>Kernel provides a bunch of syscalls for doing that: <code>mlock()</code>, <code>mlock2()</code> and <code>mlockall()</code>. As with the <code>mincore()</code>, you need to map the file first.</p><p><code>mlock2()</code> is a preferable syscall for Page Cache routines, because it has the handy flag <code>MLOCK_ONFAULT</code>:</p><blockquote><p>Lock pages that are currently resident and mark the entire range so that the remaining nonresident pages are locked when they are populated by a page fault.</p></blockquote><p>And don&rsquo;t forget about <em>limits</em> (<code>man 5 limits.conf</code>). It is very likely that you need to increased it:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ulimit -l
</span></span><span style=display:flex><span><span style=color:#ae81ff>64</span>
</span></span></code></pre></div><p>And finally, to get the amount of unevictable memory, please, check the cgroup memory controller stats for your cgroup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ grep unevictable /sys/fs/cgroup/user.slice/user-1000.slice/session-3.scope/memory.stat
</span></span><span style=display:flex><span>unevictable <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><h2 id=page-cache-vmswappiness-and-modern-kernels>Page Cache, <code>vm.swappiness</code> and modern kernels
<a class=anchor href=#page-cache-vmswappiness-and-modern-kernels>#</a></h2><p>Now, when we have understanding of the basic reclaiming theory with 4 LRU lists (for anon and file memory) and evictable/unevictable types of memory, we can talk about the sources to refill the system free memory. The kernel constantly maintains lists of free pages for itself and user-space needs. If such lists get below the threshold, the linux kernel starts to scan LRU lists in order to find pages to reclaim. This allows kernel to keep memory in some equilibrium state.</p><p>The Page Cache memory is usually evictable memory (with some rare <code>mlock()</code> exceptions). And thus, it maybe look obvious, that Page Cache should be the first and the only option for the memory eviction and reclaiming. Since disks already have all that data, right? But fortunately or unfortunately, in real production situations, this is not always the best choice.</p><p>If the system has swap (and <a href=https://chrisdown.name/2018/01/02/in-defence-of-swap.html target=_blank rel=noopener>it should have it with modern kernels</a>), the kernel has one more option. It can swap out the anonymous (not file-backed) pages. It may seem counterintuitive, but the reality is that sometimes user-space daemons can load tons of initialization code and never use it afterwards. Some programs, especially statically built, for example, could have a lot of functionality in their binaries that may be used only several times in some edge cases. In all such situations there is no much sense to keep them in valuable memory.</p><p>So, in order to control which inactive LRU list to prefer for scans, the kernel has the <code>sysctl</code> <code>vm.swappiness</code> knob.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo sysctl -a | grep swap
</span></span><span style=display:flex><span>vm.swappiness <span style=color:#f92672>=</span> <span style=color:#ae81ff>60</span>
</span></span></code></pre></div><p>There are a lot of blog posts, stories and forum threads about this magic setting. On top of that, the legacy cgroup v1 memory subsystem has its own per cgroup <code>swappiness</code> knob. All this makes information about the current <code>vm.swappiness</code> meaning hard to understand and change. But let me try to explain some recent changes and give you fresh links.</p><p>First of all, by default <code>vm.swappiness</code> is set 60, <a href=https://github.com/torvalds/linux/blob/a3fa7a101dcff93791d1b1bdb3affcad1410c8c1/mm/vmscan.c#L174-L177 target=_blank rel=noopener>the min is 0 and the max is 200</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * From 0 .. 200.  Higher means more swappy.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> vm_swappiness <span style=color:#f92672>=</span> <span style=color:#ae81ff>60</span>;
</span></span></code></pre></div><p>The 100 value means that the kernel considers anonymous and Page Cache pages equally in terms of reclamation.</p><p>Secondly, the cgroup v2 memory controller doesn&rsquo;t have the <code>swappiness</code> <a href=https://elixir.bootlin.com/linux/v5.15-rc1/source/include/linux/swap.h#L706 target=_blank rel=noopener>knob at all</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#ifdef CONFIG_MEMCG
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>mem_cgroup_swappiness</span>(<span style=color:#66d9ef>struct</span> mem_cgroup <span style=color:#f92672>*</span>memcg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* Cgroup2 doesn&#39;t have per-cgroup swappiness */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>cgroup_subsys_on_dfl</span>(memory_cgrp_subsys))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> vm_swappiness;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>/* root ? */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>mem_cgroup_disabled</span>() <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem_cgroup_is_root</span>(memcg))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> vm_swappiness;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> memcg<span style=color:#f92672>-&gt;</span>swappiness;
</span></span></code></pre></div><p>Instead, the kernel developers decided to significantly change the swappiness logic. You can check it if run <a href=https://github.com/torvalds/linux/blame/a3fa7a101dcff93791d1b1bdb3affcad1410c8c1/mm/vmscan.c#L2574 target=_blank rel=noopener><code>git blame</code> on <code>mm/vmscan.c</code> and search for the <code>get_scan_count()</code> function</a>.</p><p>For example, at the time of writing, the anonymous memory will not be touched regardless of <code>vm.swappiness</code> if <a href=https://github.com/torvalds/linux/blob/a3fa7a101dcff93791d1b1bdb3affcad1410c8c1/mm/vmscan.c#L2623-L2630 target=_blank rel=noopener>the inactive LRU Page Cache list has decent amount of pages</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>	<span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * If there is enough inactive page cache, we do not reclaim
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 * anything from the anonymous working right now.
</span></span></span><span style=display:flex><span><span style=color:#75715e>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (sc<span style=color:#f92672>-&gt;</span>cache_trim_mode) {
</span></span><span style=display:flex><span>		scan_balance <span style=color:#f92672>=</span> SCAN_FILE;
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>goto</span> out;
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>The full logic, of making decisions what and from which LRU to reclaim, you can find in the <a href=https://github.com/torvalds/linux/blob/master/mm/vmscan.c target=_blank rel=noopener><code>get_scan_count()</code>function in <code>mm/vmscan.c</code></a>.</p><p>Also, please take a look at the <code>memory.swap.high</code> and the <code>memory.swap.max</code> cgroup v2 settings. You can control them if you want to correct the <code>vm.swappiness</code> logic for your cgroup and load pattern.</p><p>Another interesting topic, which you should keep in mind when dealing with the swap and Page Cache, is the IO load during the swapping in/out processes. If you have IO pressure, you can easily hit your IO limits and, for example, degrade your Page Cache writeback performance.</p><h2 id=understanding-memory-reclaim-process-with-procpidpagemap>Understanding memory reclaim process with <code>/proc/pid/pagemap</code>
<a class=anchor href=#understanding-memory-reclaim-process-with-procpidpagemap>#</a></h2><p>Now it&rsquo;s time for a low level troubleshooting technics.</p><p>There is a <code>/proc/PID/pagemap</code> file which contains the page table information of the pid. The <a href=https://en.wikipedia.org/wiki/Page_table target=_blank rel=noopener>page table</a>, basically speaking, is an internal kernel map between page frames (real physical memory pages stored in RAM) and virtual pages of the process. Each process in the linux system has it&rsquo;s own virtual memory address space which is completely independent form other processes and physical memory addresses.</p><p>The full <code>/proc/PID/pagemap</code> and related file documentation, including data formats and ways to read it can be found in <a href=https://www.kernel.org/doc/Documentation/vm/pagemap.txt target=_blank rel=noopener>the kernel documentation folder</a>. I strongly recommend that you read it before proceeding to the sections below.</p><h3 id=page-types-kernel-page-tool><code>page-types</code> kernel page tool
<a class=anchor href=#page-types-kernel-page-tool>#</a></h3><p><code>page-types</code> is the Swiss knife of every kernel memory hacker. Its source code comes with the Linux kernel sources <a href=https://github.com/torvalds/linux/blob/master/tools/vm/page-types.c target=_blank rel=noopener>tools/vm/page-types.c</a>.</p><p>If you didn&rsquo;t install it in the first chapter:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ wget https://github.com/torvalds/linux/archive/refs/tags/v5.13.tar.gz
</span></span><span style=display:flex><span>$ tar -xzf ./v5.13.tar.gz
</span></span><span style=display:flex><span>$ cd v5.13/vm/tools
</span></span><span style=display:flex><span>$ make
</span></span></code></pre></div><p>Now let&rsquo;s use it in order to understand how many pages of our test file <code>/var/tmp/file1.db</code> the kernel has placed in Active and Inactive LRU lists:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sudo ./page-types --raw -Cl -f /var/tmp/file1.db 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>foffset cgroup  offset  len     flags
</span></span><span style=display:flex><span>/var/tmp/file1.db       Inode: <span style=color:#ae81ff>133367</span>   Size: <span style=color:#ae81ff>134217728</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>32768</span> pages<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Modify: Mon Aug <span style=color:#ae81ff>30</span> 13:14:19 <span style=color:#ae81ff>2021</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>13892</span> seconds ago<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>Access: Mon Aug <span style=color:#ae81ff>30</span> 13:15:47 <span style=color:#ae81ff>2021</span> <span style=color:#f92672>(</span><span style=color:#ae81ff>13804</span> seconds ago<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>10689</span>   @1749   21fa    <span style=color:#ae81ff>1</span>       ___U_lA_______________________P____f_____F_1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>18965</span>   @1749   24d37   <span style=color:#ae81ff>1</span>       ___U_l________________________P____f_____F_1
</span></span><span style=display:flex><span><span style=color:#ae81ff>18966</span>   @1749   <span style=color:#ae81ff>28874</span>   <span style=color:#ae81ff>1</span>       ___U_l________________________P____f_____F_1
</span></span><span style=display:flex><span><span style=color:#ae81ff>18967</span>   @1749   <span style=color:#ae81ff>10273</span>   <span style=color:#ae81ff>1</span>       ___U_l________________________P____f_____F_1
</span></span><span style=display:flex><span><span style=color:#ae81ff>18968</span>   @1749   1f6ad   <span style=color:#ae81ff>1</span>       ___U_l________________________P____f_____F_1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             flags      page-count       MB  symbolic-flags                     long-symbolic-flags
</span></span><span style=display:flex><span>0xa000010800000028             <span style=color:#ae81ff>105</span>        <span style=color:#ae81ff>0</span>  ___U_l________________________P____f_____F_1       uptodate,lru,private,softdirty,file,mmap_exclusive
</span></span><span style=display:flex><span>0xa00001080000002c              <span style=color:#ae81ff>16</span>        <span style=color:#ae81ff>0</span>  __RU_l________________________P____f_____F_1       referenced,uptodate,lru,private,softdirty,file,mmap_exclusive
</span></span><span style=display:flex><span>0xa000010800000068             <span style=color:#ae81ff>820</span>        <span style=color:#ae81ff>3</span>  ___U_lA_______________________P____f_____F_1       uptodate,lru,active,private,softdirty,file,mmap_exclusive
</span></span><span style=display:flex><span>0xa001010800000068               <span style=color:#ae81ff>1</span>        <span style=color:#ae81ff>0</span>  ___U_lA_______________________P____f_I___F_1       uptodate,lru,active,private,softdirty,readahead,file,mmap_exclusive
</span></span><span style=display:flex><span>0xa00001080000006c              <span style=color:#ae81ff>16</span>        <span style=color:#ae81ff>0</span>  __RU_lA_______________________P____f_____F_1       referenced,uptodate,lru,active,private,softdirty,file,mmap_exclusive
</span></span><span style=display:flex><span>             total             <span style=color:#ae81ff>958</span>        <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>The output contains 2 section: the first one provides per page information and the second one aggregates all pages with the same flags and counts the summary. What we need from the output in order to answer to the LRU question are <code>A</code> and <code>l</code> flags, which as you can guess, stand for &ldquo;active&rdquo; and &ldquo;inactive&rdquo; lists.</p><p>As you can see we have:</p><ul><li><code>105 + 16 = 121 pages</code> or <code>121 * 4096 = 484 KiB</code> in inactive LRU list.</li><li><code>820 + 1 + 16 = 837 pages</code> or <code>837 * 4096 = 3.2 MiB</code> in active LRU list.</li></ul><h3 id=writing-page-cache-lru-monitor-tool>Writing Page Cache LRU monitor tool
<a class=anchor href=#writing-page-cache-lru-monitor-tool>#</a></h3><p><code>page-types</code> is really useful tool for low level debugging and investigations, but its output format is hard to read and aggregate. I promised earlier that we would write our own <code>vmtouch</code>, so now we&rsquo;re creating it. Our alternative version will provide even more information about pages. It will show not only how many pages are in Page Cache, but also how many of them are in the active and the inactive LRU lists.</p><p>For doing this, we need 2 kernel files: <a href=https://www.kernel.org/doc/Documentation/vm/pagemap.txt target=_blank rel=noopener><code>/proc/PID/pagemap</code> and <code>/proc/kpageflags</code></a>.</p><p>The full code you can find in the <a href=https://github.com/brk0v/sre-page-cache-article/tree/main/lru target=_blank rel=noopener>github repo</a>, however here I would like to focus on a few important moments:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>①  err <span style=color:#f92672>=</span> syscall.Madvise<span style=color:#f92672>(</span>mm, syscall.MADV_RANDOM<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>②  ret, _, err :<span style=color:#f92672>=</span> syscall.Syscall<span style=color:#f92672>(</span>syscall.SYS_MINCORE, mmPtr, sizePtr, cachedPtr<span style=color:#f92672>)</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, p :<span style=color:#f92672>=</span> range cached <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>③      <span style=color:#66d9ef>if</span> p%2 <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>{</span> 
</span></span><span style=display:flex><span>④           _ <span style=color:#f92672>=</span> *<span style=color:#f92672>(</span>*int<span style=color:#f92672>)(</span>unsafe.Pointer<span style=color:#f92672>(</span>mmPtr + uintptr<span style=color:#f92672>(</span>pageSize*int64<span style=color:#f92672>(</span>i<span style=color:#f92672>))))</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>⑤  err <span style=color:#f92672>=</span> syscall.Madvise<span style=color:#f92672>(</span>mm, syscall.MADV_SEQUENTIAL<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    ...
</span></span></code></pre></div><ul><li>① – Here we need to disable the read ahead logic for the target file in order to protect ourselves from loading (charging) unneeded data to Page Cache by our tool;</li><li>② – Use <code>mincore()</code> syscall to get a vector of the pages in Page Cache;</li><li>③ – Here we check whether a page is in Page Cache or not;</li><li>④ – If Page Cache contains a page, we need to update the corresponding process&rsquo;s page table entry by referencing this page. Our tool has to do this in order to use the <code>/proc/pid/pagemap</code>. Otherwise the <code>/proc/pid/pagemap</code> file will not contain the target file pages and thus their flags.</li><li>⑤ – Here we are turning off the harvesting of reference bits. This is required due to kernel reclaim logic. Our tool read memory and hence influence the kerne LRU lists. By using <code>madvise()</code> with <code>MADV_SEQUENTIAL</code> we notify linux kernel to ignore our operations.</li></ul><p>Let&rsquo;s test our tool. We need 2 terminals. In the first one start our tool with <code>watch</code> (<code>man 1 watch</code>) to run our tool ever 100ms in an infinitive loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>watch -n 0.1 <span style=color:#e6db74>&#39;sudo go run ./lru.go&#39;</span>
</span></span></code></pre></div><p>And in the second terminal we will read the file with the <code>dd</code> (<code>man 1 dd</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>dd <span style=color:#66d9ef>if</span><span style=color:#f92672>=</span>/var/tmp/file1.db of<span style=color:#f92672>=</span>/dev/null
</span></span></code></pre></div><p>Demo of what you should see:</p><script id=asciicast-a6Ox5TnM6R8WiwfxlvKUM1hys src=https://asciinema.org/a/a6Ox5TnM6R8WiwfxlvKUM1hys.js async></script><p>Using the above approach you now can perform low level Page Cache investigations.</p><a href=/docs/page-cache/5-more-about-mmap-file-access/ class="book-btn right-button">Read next chapter →</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#page-cache-eviction-and-page-reclaim>Page Cache eviction and page reclaim</a><ul><li><a href=#theory>Theory</a></li><li><a href=#manual-pages-eviction-with-posix_fadv_dontneed>Manual pages eviction with <code>POSIX_FADV_DONTNEED</code></a></li><li><a href=#make-your-memory-unevictable>Make your memory unevictable</a></li><li><a href=#page-cache-vmswappiness-and-modern-kernels>Page Cache, <code>vm.swappiness</code> and modern kernels</a></li><li><a href=#understanding-memory-reclaim-process-with-procpidpagemap>Understanding memory reclaim process with <code>/proc/pid/pagemap</code></a><ul><li><a href=#page-types-kernel-page-tool><code>page-types</code> kernel page tool</a></li><li><a href=#writing-page-cache-lru-monitor-tool>Writing Page Cache LRU monitor tool</a></li></ul></li></ul></li></ul></nav></div></aside></main><div class=cookie-container><p>This website uses "<b>cookies</b>".
Using this website means you're OK with this.
If you are <b>NOT</b>, please close the site page.</p><button class=cookie-btn>
ACCEPT AND CLOSE</button></div><script src=/my_js/cookie.js></script></body></html>