<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GNU/Linux shell related internals on Viacheslav Biriukov</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/</link><description>Recent content in GNU/Linux shell related internals on Viacheslav Biriukov</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://biriukov.dev/docs/fd-pipe-session-terminal/index.xml" rel="self" type="application/rss+xml"/><item><title>GNU/Linux shell related internals</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/</guid><description>&lt;h1 id="what-every-sre-should-know-about-gnulinux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons">
 What every SRE should know about GNU/Linux shell related internals: file descriptors, pipes, terminals, user sessions, process groups and daemons
 &lt;a class="anchor" href="#what-every-sre-should-know-about-gnulinux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons">#&lt;/a>
&lt;/h1>
&lt;p>Despite the era of containers, virtualization, and the rising number of UI of all kinds, SREs often spend a significant part of their time in GNU/Linux shells. It could be debugging, testing, developing, or preparing the new infrastructure. It may be the good old &lt;code>bash&lt;/code>, the more recent and fancy &lt;code>zsh&lt;/code>, or even &lt;code>fish&lt;/code> or &lt;code>tcsh&lt;/code> with their interesting and unique features.&lt;/p></description></item><item><title>File descriptor and open file description</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/</guid><description>&lt;h1 id="file-descriptor-and-open-file-description">
 File descriptor and open file description
 &lt;a class="anchor" href="#file-descriptor-and-open-file-description">#&lt;/a>
&lt;/h1>
&lt;p>First of all, I want to touch on the two fundamental concepts of working with files:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>file descriptor;&lt;/strong>&lt;/li>
&lt;li>&lt;strong>open file description&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;p>These two abstractions are crucial for understanding the internals of a process creation, communication, and data transition.&lt;/p>
&lt;p>The first concept is a &lt;strong>file descriptor&lt;/strong> or &lt;strong>&lt;code>fd&lt;/code>&lt;/strong>. It’s a positive integer number used by file system calls instead of a file path in order to make a variety of operations. Every process has its own &lt;strong>file descriptor table&lt;/strong> (see Image 1 below). The main idea of a file descriptor is to decouple a file path (or, more correctly, an inode with minor and major device numbers) from a file object inside a process and the Linux kernel. This allows software developers to open the same file an arbitrary number of times for different purposes, with various flags (for instance: &lt;code>O_DIRECT&lt;/code>, &lt;code>O_SYNC&lt;/code>, &lt;code>O_APPEND&lt;/code>, etc.), and at different offsets.&lt;/p></description></item><item><title>Pipes</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/2-pipes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/2-pipes/</guid><description>&lt;h1 id="pipes">
 Pipes
 &lt;a class="anchor" href="#pipes">#&lt;/a>
&lt;/h1>
&lt;p>The pipe is a neat feature of the Linux kernel that allows us to build &lt;strong>one-directional communication channels&lt;/strong> between related processes (often a parent and a child).&lt;/p>
&lt;p>Pipes are usually well known from shells, where we use &amp;ldquo;&lt;code>|&lt;/code>&amp;rdquo; symbol to build command pipelines. But first of all, the pipe is a system call, or actually, there are 2 of them: &lt;code>pipe()&lt;/code> and &lt;code>pipe2()&lt;/code> (&lt;code>&lt;a href="https://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">man 2 pipe&lt;/a>&lt;/code>).&lt;/p>
&lt;p>You can think of a pipe as a memory buffer with a &lt;strong>byte stream&lt;/strong> API. Thus, by default, there are no messages or strict boundaries. The situation has changed since the Linux kernel 3.4 where the &lt;code>O_DIRECT&lt;/code> flag and the &lt;a href="https://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">packet mode&lt;/a> were introduced. We will touch all variant of working with pipes in this chapter.&lt;/p></description></item><item><title>Process groups, jobs and sessions</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/</guid><description>&lt;h1 id="process-groups-jobs-and-sessions">
 Process groups, jobs and sessions
 &lt;a class="anchor" href="#process-groups-jobs-and-sessions">#&lt;/a>
&lt;/h1>
&lt;p>A new process group is created every time we execute a command or a pipeline of commands in a shell. Inside a shell, a &lt;strong>process group&lt;/strong> is usually called a &lt;strong>job&lt;/strong>. In its turn, each process group belongs to a session. Linux kernel provides a &lt;strong>two-level hierarchy&lt;/strong> for all running processes (look at Image 3 below). As such, a process group is a set of processes, and a session is a set of related process groups. Another important limitation is that a process group and its members can be members of a single session.&lt;/p></description></item><item><title>Terminals and pseudoterminals</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/</guid><description>&lt;h1 id="terminals-and-pseudoterminals">
 Terminals and pseudoterminals
 &lt;a class="anchor" href="#terminals-and-pseudoterminals">#&lt;/a>
&lt;/h1>
&lt;p>Terminals come to us from the history of &lt;code>UNIX&lt;/code> systems. Basically, terminals provided an API for the console utils (physical ones!) to generalize interaction with users. It includes ways of reading input and writing to it in &lt;strong>two&lt;/strong> modes:&lt;/p>
&lt;ul>
&lt;li>the &lt;strong>canonical&lt;/strong> mode (default) – input is buffered line by line and read into after a new line char &lt;code>\n&lt;/code> occurs;&lt;/li>
&lt;li>the &lt;strong>noncanonical&lt;/strong> mode – an application can read terminal input a character at a time. For example &lt;code>vi&lt;/code>, &lt;code>emacs&lt;/code> and &lt;code>less&lt;/code> use this mode.&lt;/li>
&lt;/ul>
&lt;p>Nowadays, with the widespread use of rich graphical UIs, the significance of the terminals are lesser than it was, but still, we use this protocol implicitly every time we start an ssh connection.&lt;/p></description></item></channel></rss>