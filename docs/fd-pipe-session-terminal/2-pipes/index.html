<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Pipes
  #


    
        Last updated: Oct 2025
    

Contents

How shells internally create pipes
Pipe and write buffer
SIGPIPE signal
$pipestatus, $? and pipefail
FIFO or Named pipes
pv tool
Pipe usage
Packets pipe mode (O_DIRECT)
Pipe Nonblocking I/O
Partial writes and syscall restarts
Pipe performance: splice(), vmsplice() and tee()


The pipe is a neat feature of the Linux kernel that allows us to build one-directional communication channels between related processes (often a parent and a  child).">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="https://biriukov.dev/docs/fd-pipe-session-terminal/2-pipes/">
  <meta property="og:site_name" content="Viacheslav Biriukov">
  <meta property="og:title" content="Pipes">
  <meta property="og:description" content="Pipes # Last updated: Oct 2025 Contents
How shells internally create pipes Pipe and write buffer SIGPIPE signal $pipestatus, $? and pipefail FIFO or Named pipes pv tool Pipe usage Packets pipe mode (O_DIRECT) Pipe Nonblocking I/O Partial writes and syscall restarts Pipe performance: splice(), vmsplice() and tee() The pipe is a neat feature of the Linux kernel that allows us to build one-directional communication channels between related processes (often a parent and a child).">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
<title>Pipes | Viacheslav Biriukov</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.1e13c2d8521416f2409b2e0e47b515c4ee90f2718cddd31ea96d2f739bc9d7e1.css" integrity="sha256-HhPC2FIUFvJAmy4OR7UVxO6Q8nGM3dMeqW0vc5vJ1&#43;E=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.dcb69b7f72cf406432b553b1dca142c9cc7ac0f7ea624f296af7cfa987b92fe5.js" integrity="sha256-3Labf3LPQGQytVOx3KFCycx6wPfqYk8pavfPqYe5L&#43;U=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
<script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"
></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-599VSLESJL");
</script>

<link rel="stylesheet" href="/my_css/cookie.css" />
<link rel="stylesheet" href="/my_css/copy-code.css" />
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css"
/>

</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Viacheslav Biriukov</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    

      
        

      
        

      

      
        <li class="book-section-flat" >
          
  
  

  
    <span>GNU/Linux shell related internals</span>
  

          
  <ul>
    

      

      
        <li>
          
  
  

  
    <a href="/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/" class="">
      
        0. GNU/Linux shell related internals for SRE
      
    </a>
  

        </li>
      
    

      

      
        <li>
          
  
  

  
    <a href="/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/" class="">
      
        1. File descriptor and open file description
      
    </a>
  

        </li>
      
    

      

      
        <li>
          
  
  

  
    <a href="/docs/fd-pipe-session-terminal/2-pipes/" class="active">
      
        2. Pipes
      
    </a>
  

        </li>
      
    

      

      
        <li>
          
  
  

  
    <a href="/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/" class="">
      
        3. Process groups, jobs and sessions
      
    </a>
  

        </li>
      
    

      

      
        <li>
          
  
  

  
    <a href="/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/" class="">
      
        4. Terminals and pseudoterminals
      
    </a>
  

        </li>
      
    
  </ul>

        </li>
      
    

      
        
  </ul>








<div style="margin-top: 30px; margin-bottom: 30px">
  <b>More recent series:</b>
  <ul>
    <li><a href="/rust-tokio-io/">1. Async Rust & Tokio I/O Streams: Backpressure, Concurrency, and Ergonomics&nbsp;<span style="padding:0 2px;border-radius:2px ;background-color:#e84118;color: aliceblue;">new</span></li>
    <li><a href="/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/">2. Resolvers and Dual-Stack applications</li>
    <li><a href="/docs/page-cache/0-linux-page-cache-for-sre/">3. Linux Page Cache mini book</li>
    <li><a href="/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons">4. File descriptors, pipes, terminals, user sessions, process groups and daemons</li>
  </ul>
</div>

<div style="margin-top: 30px; margin-bottom: 30px">
  <b>Open Source Projects</b>
  <ul>
      <li>
          <a href="/posts/trixter-chaos-proxy/"> • trixter chaos proxy</a>
      </li>
      <li><a href="https://crates.io/crates/tokio-netem"> • tokio-netem</a></li>
  </ul>
</div>





  
<ul>
  
  <li>
    <a href="https://twitter.com/brk0v/"  target="_blank" rel="noopener"><i class="bi bi-twitter"></i>
        Twitter
      </a>
  </li>
  
  <li>
    <a href="https://www.linkedin.com/in/biriukov/"  target="_blank" rel="noopener"><i class="bi bi-linkedin"></i>
        Linkedin
      </a>
  </li>
  
  <li>
    <a href="https://github.com/brk0v/"  target="_blank" rel="noopener"><i class="bi bi-github"></i>
        Github
      </a>
  </li>
  
</ul>





<div style="margin-top: 30px;">
  <p xmlns:cc="http://creativecommons.org/ns#">
    This content is licensed under 
    <a
      href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target="_blank"
      rel="license noopener noreferrer" style="display:inline-block; ">CC BY-NC 4.0<img
      style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
      src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img
      style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
      src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img
      style="height:22px!important;margin-left:3px;vertical-align:text-bottom;"
      src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1">
    </a>
  </p>
</div>
</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Pipes</strong>

  <label for="toc-control">
    
  </label>
</div>


  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="pipes">
  Pipes
  <a class="anchor" href="#pipes">#</a>
</h1>
<p class="updated-right">
    <i>
        <time datetime="2025-10">Last updated: Oct 2025</time>
    </i>
</p>
<p><strong>Contents</strong></p>
<ul>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#how-shells-internally-create-pipes">How shells internally create pipes</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#pipe-and-write-buffer">Pipe and write buffer</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#sigpipe-signal"><code>SIGPIPE</code> signal</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#pipestatus--and-pipefail"><code>$pipestatus</code>, <code>$?</code> and <code>pipefail</code></a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#fifo-or-named-pipes">FIFO or Named pipes</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#pv-tool"><code>pv</code> tool</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#pipe-usage"><code>Pipe usage</code></a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#packets-pipe-mode-o_direct">Packets pipe mode (<code>O_DIRECT</code>)</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#pipe-nonblocking-io">Pipe Nonblocking I/O</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#partial-writes-and-syscall-restarts">Partial writes and syscall restarts</a></li>
<li><a href="/docs/fd-pipe-session-terminal/2-pipes/#pipe-performance-splice-vmsplice-and-tee">Pipe performance: <code>splice()</code>, <code>vmsplice()</code> and <code>tee()</code></a></li>
</ul>
<hr/>
<p>The pipe is a neat feature of the Linux kernel that allows us to build <strong>one-directional communication channels</strong> between related processes (often a parent and a  child).</p>
<p>Pipes are usually well known from shells, where we use  &ldquo;<code>|</code>&rdquo; symbol to build command pipelines. But first of all, the pipe is a system call, or actually, there are 2 of them:  <code>pipe()</code> and  <code>pipe2()</code> (<code><a href="https://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">man 2 pipe</a></code>).</p>
<p>You can think of a pipe as a memory buffer with a <strong>byte stream</strong> API. Thus, by default, there are no messages or strict boundaries. The situation has changed since the Linux kernel 3.4 where the <code>O_DIRECT</code> flag and the <a href="https://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">packet mode</a> were introduced. We will touch all variant of working with pipes in this chapter.</p>
<p>Another important feature of pipes is the max size of an atomic write. The  <code>PIPE_BUF</code> constant (<code><a href="https://man7.org/linux/man-pages/man7/pipe.7.html" target="_blank" rel="noopener">man 7 pipe</a></code>) determines it and sets it to <a href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/limits.h#L14" target="_blank" rel="noopener">4096 bytes</a>. Please, read the man carefully if you want to rely on this guarantee.</p>
<p>As a result of a streaming nature, a reader and a writer can use completely different user-space buffer sizes if they want. All written bytes are read sequentially, so  making the <code>lseek()</code> syscall for a pipe is impossible.</p>
<p>The pipes also provide  a convenient notification API for both ends. The write calls to a pipe block if the internal kernel buffer is full.  The writer will block or return <code>EAGAIN</code> (if it’s in nonblocking mode) until sufficient data has been read from the pipe to allow the writer to complete. On the other hand, if all pipe readers close their read file descriptors, the writer will get the <code>SIGPIPE</code> signal from the kernel, and all subsequent <code>write()</code> calls will return the <code>EPIPE</code> error.</p>
<p>From a reader’s perspective, a pipe can return a zero size read (end-of-file, <code>EOF</code>) if all writers close all their write pipe file descriptors. A reader blocks if there is nothing to read until data is available (you can change this by opening a pipe in the nonblocking mode).</p>
<img alt="Using a pipe to connect 2 processes" src="../images/pipe.png" width="70%" class="img-center">
<div class="text-center">
Figure 2. – Using a pipe to connect 2 processes
</div>
<p>Pipes are widely used in shells. The elegance of such an approach is that processes don’t have to know that they use pipes. They continue working with their standard file descriptors (<code>stdin</code>, <code>stdout</code> and <code>stderr</code>) as usual. Developers also don’t need to make any changes in their program&rsquo;s source code in order to support this concept. It makes the process of connecting 2 programs composite, flexible, fast and reliable. Of course, in order to support such communication, shells have to do some additional work before spawning new commands (more details and examples below).</p>
<p>Internally, a <strong>pipe buffer</strong> is a <strong>ring buffer</strong> with slots. Each slot has a size of a <code>PIPE_BUF</code> constant. The number of slots is variable, and the default number is <a href="https://elixir.bootlin.com/linux/v5.18.10/source/include/linux/pipe_fs_i.h#L5" target="_blank" rel="noopener">16</a>. So, if we multiply 16 by 4KiB, we can get a <strong>default size of 64KiB for a pipe buffer</strong>.</p>
<p>We can control the capacity of a pipe by calling the <code>fcntl()</code> with the <code>F_SETPIPE_SZ</code> flag.   A pipe&rsquo;s system max size limit can be found in the <code>/proc/sys/fs/pipe-max-size</code> (<code><a href="https://man7.org/linux/man-pages/man7/pipe.7.html" target="_blank" rel="noopener">man 7 pipe</a></code>).</p>
<p>We can get the size of unread bytes in a pipe by calling <code>ioctl()</code> with <code>FIONREAD</code> operation. We’ll write an example later.</p>
<p>The usual question about pipes is, do we really need them? Can we use regular files instead? There are several issues and lacking of API with using files instead of pipes:</p>
<ul>
<li>There is no easy way to notify a writer that a reader has stopped reading.</li>
<li>For a reader, we can set up  <code>inotify</code> (<code><a href="https://man7.org/linux/man-pages/man7/inotify.7.html" target="_blank" rel="noopener">man 7 inotify</a></code>) to efficiently track whether new changes appear.</li>
<li>Also, regular files don’t have nonblocking API (this is changing with <code>io_uring</code>, but still, it’s much harder to use it in comparison with the <code>pipe()</code> syscall).</li>
</ul>
<p>One final introduction remark is that a pipe can be used by more than 2 processes. It’s possible to have multiple writers and readers for a single pipe. It’s not usuall because of the streaming nature of pipes and no clear boundaries by default, but with the new packet mode, it&rsquo;s become more useful in some situations.</p>
<h2 id="how-shells-internally-create-pipes">
  How shells internally create pipes
  <a class="anchor" href="#how-shells-internally-create-pipes">#</a>
</h2>
<p>With shells we usually use pipes to connect the <code>stdout</code> and/or the <code>stderr</code> of a process and <code>stdin</code> of another process. For example:</p>
<p><code>stdout</code> to <code>stdin</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ command1 | command2
</span></span></code></pre></div><p><code>stdout</code> and <code>stderr</code> to <code>stdin</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ command1 |&amp; command2
</span></span></code></pre></div><p>or</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>command1 2&gt;&amp;<span style="color:#ae81ff">1</span> | command2
</span></span></code></pre></div><p>So let’s understand how  shells connect the following 2 commands internally.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ ls -la | wc -l
</span></span></code></pre></div><p>As we already know, a shell process has three special standard open file descriptors. Thus, all its children inherit them by default because of the <code>fork()</code> syscalls. The following simple program shows how a shell can create a pipe and connect 2 programs. It creates a pipe in the parent process, then makes a <code>fork()</code> call twice in order to run <code>execve()</code> for the <code>ls</code> and <code>wc</code> binaries. Before the <code>execve()</code> calls, the children duplicate the needed standart fd with one of the ends of the pipe.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r, w <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>pipe()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ls_pid <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>fork()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> ls_pid:
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># child</span>
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>close(r)
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>dup2(w, sys<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>fileno())
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>close(w)
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>execve(<span style="color:#e6db74">&#34;/bin/ls&#34;</span>, [<span style="color:#e6db74">&#34;/bin/ls&#34;</span>, <span style="color:#e6db74">&#34;-la&#34;</span>, ], os<span style="color:#f92672">.</span>environ)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>wc_pid <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>fork()
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> wc_pid:
</span></span><span style="display:flex;"><span>   <span style="color:#75715e"># child</span>
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>close(w)
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>dup2(r, sys<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>fileno())
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>close(r)
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>execve(<span style="color:#e6db74">&#34;/usr/bin/wc&#34;</span>, [<span style="color:#e6db74">&#34;/usr/bin/wc&#34;</span>, <span style="color:#e6db74">&#34;-l&#34;</span>], os<span style="color:#f92672">.</span>environ)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>os<span style="color:#f92672">.</span>close(r)
</span></span><span style="display:flex;"><span>os<span style="color:#f92672">.</span>close(w)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>) :
</span></span><span style="display:flex;"><span>   pid, status <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>waitpid(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>And if we run it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./simple_pipe.py
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">12</span>
</span></span></code></pre></div><p>The one important note about the above code is how I close all not needed file descriptors of the pipe. We have to close them to allow the kernel to send us correct signals, block operations, and return <code>EOF</code> when there are no more writers.</p>
<h2 id="pipe-and-write-buffer">
  Pipe and write buffer
  <a class="anchor" href="#pipe-and-write-buffer">#</a>
</h2>
<p>Modern programming languages (for example, <code>python</code>) often buffer all their writes in memory before the actual write syscall executes. The main idea of such buffering is to get better <code>I/O</code> performance. It’s cheaper to make one big <code>write()</code> call than several smaller ones. There are 2 types of buffers that are widely used:</p>
<ul>
<li><strong>Block buffer</strong> <br>
For example, if its size is 4KiB, the buffer will write its content (flush) to the underlying fd only when it fills up completely or the explicit <code>flush()</code> call is invoked.</li>
<li><strong>Line buffer</strong> <br>
This buffer type flushes its content when the new line character write occurs to the buffer.</li>
</ul>
<p>The <code>python</code> (and other programming languages) changes the buffer type depending on the type of the underlying file descriptor. If the fd is a terminal, the buffer will be a line buffer. That makes sense because when we are in the interactive shell, we want to get the output as soon as possible. However, a block buffer will be used for pipes and regular files because it’s usually OK to postpone the flush for better performance.</p>
<p>The <code>libc</code> function <code>isatty()</code> (<a href="https://www.man7.org/linux/man-pages/man3/isatty.3.html" target="_blank" rel="noopener">man 3 isatty</a>) tests whether a file descriptor refers to a terminal.</p>
<p>Let’s demonstrate this behavior with 2 scripts connected by a pipe. The first one will print 10 lines to <code>stdout</code>, and the other one will consumethese lines from its <code>stdin</code>.</p>
<p>The printing script <code>print.py</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>   print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>   time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span></code></pre></div><p>And the consumer script:<code> stdin.py</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> fileinput
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, line <span style="color:#f92672">in</span> enumerate(fileinput<span style="color:#f92672">.</span>input()):
</span></span><span style="display:flex;"><span>   print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>line<span style="color:#f92672">.</span>rstrip()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>If you run the <code>print.py</code>,  you should see how the output will be printed in a line-by-line manner:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./print.py
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>Now, if we run these 2 scripts with a pipe, you should see that the output freezes for a second, and it prints all lines at once afterwards:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./print.py | python stdin.py
</span></span><span style="display:flex;"><span>1: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>2: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>3: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>4: <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>Now let’s make it smoother. We need to add a <code>flush()</code> call after each <code>print()</code> in the <code>print.py</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>   print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>   sys<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>flush()
</span></span><span style="display:flex;"><span>   time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.1</span>)
</span></span></code></pre></div><p>And rerun it. Now, you should be able to see that the lines appear smoothly one-by-one:<code> </code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./print.py | python stdin.py
</span></span><span style="display:flex;"><span>1: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>2: <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>3: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>4: <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><p>It’s worth knowing that some core utilities have an option to control their buffering. For example, the <code>grep</code> can be forced to use a per  line buffer with the <code>--line-buffered</code> option. Of course, this will give you a more interactive experience with some performance penalties. You can play with it and compare the outputs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ strings /var/tmp/file1.db | grep --line-buffered -E <span style="color:#e6db74">&#34;^sek&#34;</span> | cat
</span></span><span style="display:flex;"><span>sek.^ <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>sekA
</span></span><span style="display:flex;"><span>sekt
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ strings /var/tmp/file1.db | grep  -E <span style="color:#e6db74">&#34;^sek&#34;</span> | cat
</span></span><span style="display:flex;"><span>sek.^ <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>sekA
</span></span><span style="display:flex;"><span>sekt
</span></span></code></pre></div><h2 id="sigpipe-signal">
  <code>SIGPIPE</code> signal
  <a class="anchor" href="#sigpipe-signal">#</a>
</h2>
<p>One of the exciting aspects of the pipes is their notification and synchronization features.</p>
<p>We intentionally closed all unused fd in the above code with <code>fork()</code> and <code>execve()</code> calls. The reason for doing that was not only our desire to save file descriptors and write a cleaner code but also to support the pipe notification features.</p>
<p>If all readers close their fd of the pipe and a writer tries to send data into it, the writer process will get the <code>SIGPIPE</code> signal from the kernel. This is a brilliant idea. Let’s assume we want to <code>grep</code> a huge <code>nginx</code> access log (for example, 500GiB) in order to find a target string and care only about the first three results:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat /var/log/nginx/access.log | grep some_string | head -3
</span></span></code></pre></div><p>So, if we assume that the log file has all three target lines somewhere at the beginning of the file, the <code>head</code> command will exit almost immediately.  Thus we don’t need to continue reading the file. As so, when the <code>head</code> util exits, it closes all its fd, including the <code>stdin</code> (which is a pipe). The subsequent writes from the <code>grep</code> will cause the kernel to send the <code>SIGPIPE</code> signal to it. The default handler for the <code>SIGPIPE</code> signal is to terminate, so <code>grep</code> will exit and close all its fd, including its <code>stdin</code>. And in its turn, the <code>cat</code> command  will exit after receiving its own <code>SIGPIPE</code> signal. So the exit of the <code>head</code> starts the cascading exit of the whole shell pipeline.</p>
<p>A shell are usually waiting on the processes with the <code>waitpid()</code> syscall and collects all return codes. When it sees that all the process pipeline has finished, the shell sets the exit status variable <code>$?</code> to the returned code of the last command in the pipeline (<code>head</code> in our case) and populates the <code>$PIPESTATUS</code> (<code>bash</code>)  or <code>$pipestatus</code> (<code>zsh</code>) array variable with all return codes of the piplene.</p>
<p>Let me demonstrate it. As you can see, all the above works without any support in the <code>cat</code>, <code>grep</code> or <code>head</code> tools. It’s the beauty of the pipes and shells collaboration.</p>
<p>Now we are ready to write our own prove of the above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> signal
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">signal_handler</span>(signum, frame):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[pipe] signal number: </span><span style="color:#e6db74">{</span>signum<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>	os<span style="color:#f92672">.</span>_exit(signum)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>signal<span style="color:#f92672">.</span>signal(signal<span style="color:#f92672">.</span>SIGPIPE, signal_handler)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">9999</span>):
</span></span><span style="display:flex;"><span>	print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span></code></pre></div><p>And run it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./print.py | head -3
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>pipe<span style="color:#f92672">]</span> signal number: <span style="color:#ae81ff">13</span> &lt;--------------
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">${</span>PIPESTATUS[@]<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">13</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><h2 id="pipestatus--and-pipefail">
  <code>$pipestatus</code>, <code>$?</code> and <code>pipefail</code>
  <a class="anchor" href="#pipestatus--and-pipefail">#</a>
</h2>
<p>We are ready to take a bit closer look at the exit statuses of a <code>bash</code> pipeline. By default, the last command in the pipe is used for the <code>$?</code> variable, which could sometimes lead to unexpected results. For instance:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#39;some text&#39;</span> | grep no_such_text | cut -f <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>$ echo $?
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#39;some text&#39;</span> | grep no_such_text | cut -f <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">${</span>PIPESTATUS[@]<span style="color:#e6db74">}</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span> <span style="color:#ae81ff">1</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>But fortunately, we can change this behavior with a <code>pipefail</code> <code>bash</code> option:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ set -o pipefail
</span></span><span style="display:flex;"><span>$ echo <span style="color:#e6db74">&#39;some text&#39;</span> | grep no_such_text | cut -f <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>$ echo $?
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h2 id="fifo-or-named-pipes">
  FIFO or Named pipes
  <a class="anchor" href="#fifo-or-named-pipes">#</a>
</h2>
<p>So far, we have been talking about pipes in the context of related processes (a parent and its children), but we also have the option to share a pipe easily among any number of unrelated processes. We can create a disk reference for a pipe which is called a <strong>named pipe</strong> or a <strong>FIFO file</strong>.</p>
<p>There is one high-level <code><a href="https://man7.org/linux/man-pages/man7/pipe.7.html" target="_blank" rel="noopener">man 7 fifo</a></code> and a tool to create a fifo file mkfifo (<code><a href="https://man7.org/linux/man-pages/man1/mkfifo.1.html" target="_blank" rel="noopener">man 1 mkfifo</a>)</code>).</p>
<p>The permission control is based on regular file permissions. So, if a process has &ldquo;write&rdquo; permissions, it can write to this named pipe.</p>
<p>All other aspects are identical to a regular pipe. The kernel internally creates the same pipe object and <strong>doesn’t store any data on disk</strong>.</p>
<p>The FIFO file could be helpful when you need to build a connection between completely unrelated programs or daemons without changing their source code.</p>
<h2 id="pv-tool">
  <code>pv</code> tool
  <a class="anchor" href="#pv-tool">#</a>
</h2>
<p><code>pv</code> or pipe viewer (<code><a href="https://man7.org/linux/man-pages/man1/pv.1.html" target="_blank" rel="noopener">man 1 pv</a></code>) is a nifty tool to work with pipes and file descriptors. We can insert it in any pipeline place, and it will show additional info such as ETA, write rate and amount of transferred data with an incredible visual progress bar.</p>
<p>Here is the basic usage with a file shows us how fast the reading <code>strings</code> command can consume a file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ pv /var/tmp/file1.db | strings &gt; /dev/null
</span></span><span style="display:flex;"><span> 100MiB 0:00:01 <span style="color:#f92672">[</span>67.9MiB/s<span style="color:#f92672">]</span> <span style="color:#f92672">[===========================================</span>&gt;<span style="color:#f92672">]</span> 100%
</span></span></code></pre></div><p>It also can rate limit a pipe, which is really useful for tests:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat /var/tmp/file1.db | pv --rate-limit<span style="color:#f92672">=</span>1K | strings
</span></span></code></pre></div><p>Another neat feature is monitoring a process’s progress for every open file descriptor. Under the hood it uses <code>procfs</code> and <code>fdinfo</code> folders to get the positions for all opened files:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ pv -d <span style="color:#ae81ff">6864</span>
</span></span><span style="display:flex;"><span>   3:/var/tmp/file1.db:  <span style="color:#ae81ff">234</span> B 0:00:01 <span style="color:#f92672">[</span>0.00 B/s<span style="color:#f92672">]</span>   <span style="color:#f92672">[</span>&gt;                  	<span style="color:#f92672">]</span>  0% ETA 0:00:00
</span></span><span style="display:flex;"><span> 123:/var/tmp/file1.db:  <span style="color:#ae81ff">234</span> B 0:00:01 <span style="color:#f92672">[</span>0.00 B/s<span style="color:#f92672">]</span> <span style="color:#f92672">[</span>&gt;                  	<span style="color:#f92672">]</span>  0% ETA 0:00:00
</span></span></code></pre></div><h2 id="pipe-usage">
  Pipe usage
  <a class="anchor" href="#pipe-usage">#</a>
</h2>
<p>We can get the size of unread bytes in a pipe by calling <code>ioctl()</code> with <code>FIONREAD</code> and a pipe fd. But how to get pipe usage from an unrelated process that doesn’t have the pipe file descriptor, for instance from a monitoring tool. Or, for example, we started a long running pipeline and not sure if the consumer of the pipe is reading data:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/urandom | strings &gt; /dev/null
</span></span></code></pre></div><p>We can, of course, use <code>strace</code> and check the <code>read()</code> syscalls in its output, but the reader could a <code>read()</code> syscall with a huge buffer that we can miss in the <code>strace</code> output.</p>
<p>So, in order to achieve the goal, we need to get the pipe file descriptor somehow. The most elegant solution (but not without drawbacks) is to steal the fd with <code>sys_pidfd_getfd()</code> system call and then use <code>ioctl</code> to get usage information.</p>
<p>The code can be something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;strconv&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;syscall&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;golang.org/x/sys/unix&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">sys_pidfd_open</span>  = <span style="color:#ae81ff">434</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">sys_pidfd_getfd</span> = <span style="color:#ae81ff">438</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">FIONREAD</span>        = <span style="color:#ae81ff">0x541B</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pidfd_open</span>(<span style="color:#a6e22e">pid</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">r1</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Syscall</span>(<span style="color:#a6e22e">sys_pidfd_open</span>, uintptr(<span style="color:#a6e22e">pid</span>), <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">r1</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">pidfd_getfd</span>(<span style="color:#a6e22e">pidfd</span>, <span style="color:#a6e22e">targetfd</span> <span style="color:#66d9ef">int</span>) (<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">error</span>) {
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">r1</span>, <span style="color:#a6e22e">_</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Syscall</span>(<span style="color:#a6e22e">sys_pidfd_getfd</span>, uintptr(<span style="color:#a6e22e">pidfd</span>), uintptr(<span style="color:#a6e22e">targetfd</span>), <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">err</span>
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">r1</span>), <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">var</span> (
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">pid</span>, <span style="color:#a6e22e">fd</span> <span style="color:#66d9ef">int</span>
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">err</span>     <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>   )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">pid</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">fd</span>, <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">strconv</span>.<span style="color:#a6e22e">Atoi</span>(<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>       panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">pidfd</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pidfd_open</span>(<span style="color:#a6e22e">pid</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>       panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">newFd</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">pidfd_getfd</span>(<span style="color:#a6e22e">pidfd</span>, <span style="color:#a6e22e">fd</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>       panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">size</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">unix</span>.<span style="color:#a6e22e">IoctlGetInt</span>(<span style="color:#a6e22e">newFd</span>, <span style="color:#a6e22e">FIONREAD</span>)
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>           panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;size:\t%d\n&#34;</span>, <span style="color:#a6e22e">size</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Run our target pipeline:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ dd <span style="color:#66d9ef">if</span><span style="color:#f92672">=</span>/dev/urandom | pv --rate-limit 30K | strings &gt; /dev/null
</span></span><span style="display:flex;"><span>^ KiB 0:00:16 <span style="color:#f92672">[</span>27.6KiB/s<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>And run our tool:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo go run ./pipe_capacity.go <span style="color:#ae81ff">19990</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>size:   <span style="color:#ae81ff">62464</span>
</span></span><span style="display:flex;"><span>size:   <span style="color:#ae81ff">62464</span>
</span></span><span style="display:flex;"><span>size:   <span style="color:#ae81ff">63488</span>
</span></span><span style="display:flex;"><span>size:   <span style="color:#ae81ff">63488</span>
</span></span><span style="display:flex;"><span>size:   <span style="color:#ae81ff">63488</span>
</span></span><span style="display:flex;"><span>size:   <span style="color:#ae81ff">63488</span>
</span></span><span style="display:flex;"><span>size:   <span style="color:#ae81ff">63488</span>
</span></span></code></pre></div><p>The main drawback of such a technique is that we are holding the write end of the pipe open. This can lead to an extended life of the reader because it will block on an empty pipe instead of getting <code>EOF</code> (see the pipe notification feature explained above).</p>
<h2 id="packets-pipe-mode-o_direct">
  Packets pipe mode (<code>O_DIRECT</code>)
  <a class="anchor" href="#packets-pipe-mode-o_direct">#</a>
</h2>
<p>Since the Linux kernel 3.4, a pipe can be created with the <code>O_DIRECT</code> flag. It puts it into <a href="https://man7.org/linux/man-pages/man2/pipe.2.html" target="_blank" rel="noopener">packet mode</a>. From my point of view, this mode can be successfully used only with writes and reads that are less or equal to  the <code>PIPE_BUF</code> size (4KiB) because atomicity is guaranteed only in this case.</p>
<p>The packet mode is different from the default stream mode in the following ways:</p>
<ul>
<li>The kernel doesn’t try to merge writes into one ring buffer slot <a href="https://elixir.bootlin.com/linux/v5.19/source/fs/pipe.c#L462" target="_blank" rel="noopener">here</a> and <a href="https://elixir.bootlin.com/linux/v5.19/source/fs/pipe.c#L527" target="_blank" rel="noopener">here</a>.  It, of course, leads to the underutilization of the pipe buffer, but provides guarantee of boundaries instead.</li>
<li>Readers with <code>read()</code> of  <code>PIPE_BUF</code>  size get the same messages as the writers wrote;</li>
<li>If the reader’s buffer is less than the data in the slot (some misconfigured reader infiltrated), then the remaining data <a href="https://elixir.bootlin.com/linux/v5.19/source/fs/pipe.c#L317" target="_blank" rel="noopener">is discarded</a> to protect the boundaries of messages.</li>
</ul>
<p>Now let’s write an example with 2 writers and 2 readers. Every writer writes less than 4KiB, so readers will get one full message on every read:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PIPE_BUF <span style="color:#f92672">=</span> <span style="color:#ae81ff">4096</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;supervisor: </span><span style="color:#e6db74">{</span>os<span style="color:#f92672">.</span>getpid()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r, w <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>pipe2(os<span style="color:#f92672">.</span>O_DIRECT)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># fork 2 writers</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> instance <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>   writer_pid <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>fork()
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> writer_pid:
</span></span><span style="display:flex;"><span>       print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;writer</span><span style="color:#e6db74">{</span>instance<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>os<span style="color:#f92672">.</span>getpid()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       os<span style="color:#f92672">.</span>close(r)
</span></span><span style="display:flex;"><span>       pid <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getpid()
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>           os<span style="color:#f92672">.</span>write(w, <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;writer</span><span style="color:#e6db74">{</span>instance<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>encode())
</span></span><span style="display:flex;"><span>           time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># fork 2 readers</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> instance <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>   reader_pid <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>fork()
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> reader_pid:
</span></span><span style="display:flex;"><span>       print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;reader</span><span style="color:#e6db74">{</span>instance<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>os<span style="color:#f92672">.</span>getpid()<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       os<span style="color:#f92672">.</span>close(w)
</span></span><span style="display:flex;"><span>       pid <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getpid()
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>           data <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>read(r, PIPE_BUF)
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> len(data):
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>           print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;reader</span><span style="color:#e6db74">{</span>instance<span style="color:#e6db74">}</span><span style="color:#e6db74">: </span><span style="color:#e6db74">{</span>data<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>os<span style="color:#f92672">.</span>close(r)
</span></span><span style="display:flex;"><span>os<span style="color:#f92672">.</span>close(w)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">4</span>):
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>waitpid(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>Run it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./packets.py
</span></span><span style="display:flex;"><span>supervisor: <span style="color:#ae81ff">1200</span>
</span></span><span style="display:flex;"><span>writer0: <span style="color:#ae81ff">1201</span>
</span></span><span style="display:flex;"><span>reader0: <span style="color:#ae81ff">1203</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 0&#39;</span>
</span></span><span style="display:flex;"><span>writer1: <span style="color:#ae81ff">1202</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer1: 0&#39;</span>
</span></span><span style="display:flex;"><span>reader1: <span style="color:#ae81ff">1204</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer1: 1&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 1&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 2&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer1: 2&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 3&#39;</span>
</span></span><span style="display:flex;"><span>reader1: b<span style="color:#e6db74">&#39;writer1: 3&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 4&#39;</span>
</span></span><span style="display:flex;"><span>reader1: b<span style="color:#e6db74">&#39;writer1: 4&#39;</span>
</span></span></code></pre></div><p>If we remove the <code>O_DIRECT</code> flag and rerun it, we can see how readers start to break the boundaries of messages and, from time to time, get 2 messages instead of 1. The situation could be even worse, and the boundaries could be violated if a reader reads a buffer less than a writer’s written.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>…
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 2writer1: 2&#39;</span>
</span></span><span style="display:flex;"><span>reader1: b<span style="color:#e6db74">&#39;writer0: 3writer1: 3&#39;</span>
</span></span><span style="display:flex;"><span>reader1: b<span style="color:#e6db74">&#39;writer1: 4writer0: 4&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 5&#39;</span>
</span></span><span style="display:flex;"><span>reader1: b<span style="color:#e6db74">&#39;writer1: 5&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 6writer1: 6&#39;</span>
</span></span><span style="display:flex;"><span>reader1: b<span style="color:#e6db74">&#39;writer1: 7&#39;</span>
</span></span><span style="display:flex;"><span>reader0: b<span style="color:#e6db74">&#39;writer0: 7&#39;</span>
</span></span></code></pre></div><h2 id="pipe-nonblocking-io">
  PIPE Nonblocking I/O
  <a class="anchor" href="#pipe-nonblocking-io">#</a>
</h2>
<p>Unlike regular files, pipes natively support nonblocking I/O. You can create a new pipe or switch an existing pipe to the nonblocking I/O mode. The most important outcome of doing this is the ability to poll a pipe using <code>poll()</code>, <code>select()</code> and <code>epoll()</code> event notification facilities. Nonblocking mode saves the CPU (if correctly written) and provides a unified API for programs and developers.</p>
<p>Nonblocking mode might be also useful to write user space busy loops in order to get better throughput by trading more CPU usage. The idea is to skip some kernel <a href="https://elixir.bootlin.com/linux/v5.19/source/fs/pipe.c#L345" target="_blank" rel="noopener">wake up logic</a> and return from kernel mode as soon as possible.</p>
<p>The following example shows that even with <code>python</code>, where exceptions are slow, we can get a better throughput with a busy loop:</p>
<p>No busy loop code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rand <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getrandom(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">16</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>   os<span style="color:#f92672">.</span>write(<span style="color:#ae81ff">1</span>, rand)
</span></span></code></pre></div><p>Max throughput: in my virtual machine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./no_busy_loop.py  | pv | strings &gt; /dev/null
</span></span><span style="display:flex;"><span> 631MiB 0:00:10 <span style="color:#f92672">[</span>74.5MiB/s<span style="color:#f92672">]</span>
</span></span></code></pre></div><p>With busy loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> fcntl
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flags <span style="color:#f92672">=</span> fcntl<span style="color:#f92672">.</span>fcntl(<span style="color:#ae81ff">1</span>, fcntl<span style="color:#f92672">.</span>F_GETFL, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>fcntl<span style="color:#f92672">.</span>fcntl(<span style="color:#ae81ff">1</span>, fcntl<span style="color:#f92672">.</span>F_SETFL, flags <span style="color:#f92672">|</span> os<span style="color:#f92672">.</span>O_NONBLOCK)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rand <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getrandom(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">16</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>       n <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>write(<span style="color:#ae81ff">1</span>, rand)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">BlockingIOError</span>:
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">continue</span>
</span></span></code></pre></div><p>I was able to get 10% better throughput in my test vm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ python3 ./busy_loop.py  | pv | strings &gt; /dev/null
</span></span><span style="display:flex;"><span> 799MiB 0:00:11 <span style="color:#f92672">[</span>82.7MiB/s<span style="color:#f92672">]</span>
</span></span></code></pre></div><h2 id="partial-writes-and-syscall-restarts">
  Partial writes and syscall restarts
  <a class="anchor" href="#partial-writes-and-syscall-restarts">#</a>
</h2>
<p>Now we are ready to delve into the kernel internals a bit deeper. Let’s assume we want to write 512 MiB of some data to a pipe. We already have it all in memory and call the <code>write()</code> syscall:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>data <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getrandom(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">29</span>) <span style="color:#75715e"># 512 MiB</span>
</span></span><span style="display:flex;"><span>os<span style="color:#f92672">.</span>write(<span style="color:#ae81ff">1</span>, data) <span style="color:#75715e"># where stdout is a pipe in a shell pipeline</span>
</span></span></code></pre></div><p>We know from the above that the size of a pipe by default is 64KiB, but the <code><a href="https://man7.org/linux/man-pages/man7/pipe.7.html" target="_blank" rel="noopener">man 7 pipe</a></code> says:</p>
<blockquote class="book-hint info">
  Applications <strong>should not rely on a particular capacity</strong>: an application should be designed so that a reading process consumes data as soon as it is available, so that a writing process does not remain blocked.
</blockquote>

<p>It means that, in default blocking I/O mode, our <code>write()</code> call should block until all bytes have not been transferred through a pipe. It makes sense, the userspace application should not, in theory, care about the underlying kernel machinery. We have a userspace buffer with data, and we should be able to write it in one blocking call. But fortunately or unfortunately, things are a bit more complicated.</p>
<p>One theory we also need to recall here is that the kernel puts a process into a sleep state if a syscall blocks. There are 2 sleep types: interruptible (<code>S</code>) sleep and uninterruptible (<code>D</code>) sleep.</p>
<p>For example, the above code snippet with the <code>write()</code> syscall puts a process into the interruptible state (because it writes to a pipe):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ ps axu | grep write2.py
</span></span><span style="display:flex;"><span>vagrant    S+   20:36   0:15 python3 ./write2.py
</span></span></code></pre></div><p>     where <code>S</code> informs us that the process is in the interruptible sleep (waiting for an event to complete).</p>
<p>Such processes are removed from the kernel scheduler list and are put in a dedicated queue waiting for a particular event.</p>
<p>The interruptible sleep state differs from the uninterruptible in that the kernel can deliver signals to the process. Rephrasing, it’s possible to receive and handle signals during the blocking syscall in the interruptible sleep state. But the reasonable question is, what happens after the signal is handled in the middle of such a syscall? Let’s figure it out.</p>
<p>We start with the <code><a href="https://elixir.bootlin.com/linux/v5.19/source/fs/pipe.c#L416" target="_blank" rel="noopener">pipe_write()</a></code> kernel function, where we can find the following code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">signal_pending</span>(current)) {
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ret)
</span></span><span style="display:flex;"><span>       ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ERESTARTSYS;
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above confirms that the signal could interrupt the process during the blocking pipe <code>write()</code> syscall. The interesting part here is the <code>ret</code> variable. If it doesn’t have anything, the kernel sets it to the <code>-ERESTARTSYS</code> error. Otherwise, the kernel leaves it as is. In both cases, the kernel exits from the infinitive <code><a href="https://elixir.bootlin.com/linux/v5.19/source/fs/pipe.c#L480" target="_blank" rel="noopener">for</a></code> loop. This infinitive <code>for</code> loop is what keeps the <code>write()</code> syscall in the blocking state, and it’s in charge of data transferring between usersapace buffer (512 MiB in our case) and kernel space pipe ring buffer.</p>
<p>In turn, the <code>ret</code> variable stores the number of transferred through the pipe bytes. It can be much bigger than the 64KiB default pipe size because there is always at least one consumer that reads from this pipe.</p>
<p>One more piece of information that will help us understand the following examples and behavior is the <code><a href="https://elixir.bootlin.com/linux/v5.19/source/include/linux/errno.h#L14" target="_blank" rel="noopener">ERESTARTSYS</a></code> error. It signals that the kernel can safely restart a syscall because it hasn&rsquo;t done any meaningful work and has no side effects.</p>
<p>With all the above said, we are ready to do some coding and debugging in order to answer the question of whether it is sufficient to do one <code>write()</code> to a pipe.</p>
<blockquote class="book-hint info">
  In our tests we’ll use <code><a href="https://github.com/iovisor/bpftrace" target="_blank" rel="noopener">bpftrace</a></code>. It’s a handy tool that allows us to trace kernel functions via <code>eBPF</code> trampolines, which allows kernel code to call into <code>BPF</code> programs with practically zero overhead.
</blockquote>

<p>We’ll be tracing a <code>pipe_write()</code> kernel function to get insides about the actual pipe writes.</p>
<p>Let’s start with a producer of data. Here we have a signal handler for the <code>SIGUSR1</code> signal, which prints the signal code, a buffer with random 512 MiB, and one <code>write()</code> syscall to <code>stdout</code> fd.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> signal
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">signal_handler</span>(signum, frame):
</span></span><span style="display:flex;"><span>   print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;signal </span><span style="color:#e6db74">{</span>signum<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>frame<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> ,file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>signal<span style="color:#f92672">.</span>signal(signal<span style="color:#f92672">.</span>SIGUSR1, signal_handler)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(os<span style="color:#f92672">.</span>getpid(), file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rand <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getrandom(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">29</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;generated&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>write(<span style="color:#ae81ff">1</span>, rand)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;written: </span><span style="color:#e6db74">{</span>n<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span></code></pre></div><p>Now we need to write a consumer for a pipe. It will sleep for 30 seconds and afterward reads all data from the <code>stdin</code> in 4KiB chunks.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-py" data-lang="py"><span style="display:flex;"><span><span style="color:#f92672">import</span> time
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;start sleeping&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">30</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;stop sleeping&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>r <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>buffer<span style="color:#f92672">.</span>read(<span style="color:#ae81ff">4096</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> len(r) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>   r <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>stdin<span style="color:#f92672">.</span>buffer<span style="color:#f92672">.</span>read(<span style="color:#ae81ff">4096</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;finished reading&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span></code></pre></div><p>We are ready for experiments. Let’s launch <code>bpftrace</code> first. We’re looking for <code>python3</code> commands and want to print the return value of the <code>pipe_write()</code> kernel function. Please, run the following in a terminal window.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo bpftrace -e <span style="color:#e6db74">&#39;kretfunc:pipe_write /comm == &#34;python3&#34;/  { printf(&#34;%d\n&#34;, retval);}&#39;</span>
</span></span><span style="display:flex;"><span>Attaching <span style="color:#ae81ff">1</span> probe...
</span></span></code></pre></div><p>In another terminal window, we need to start our shell pipeline under <code>strace</code> tool for the writer. <code>strace</code> logs all <code>write()</code> syscalls into <code>log.txt</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ strace --output log.txt -s0 -e write -- python3 ./write2.py | python3 ./slow_reader.py
</span></span><span style="display:flex;"><span>start sleeping
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1791</span>
</span></span><span style="display:flex;"><span>generated
</span></span></code></pre></div><p>We are in a situation where the buffer is full, the writer is in the interruptible sleep state (<code>S</code>), and the reader is still sleeping. It’s time to open one more console and send the <code>SIGUSR1</code> signal to the blocked writer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ kill -USR1 <span style="color:#ae81ff">1791</span>
</span></span></code></pre></div><p>In the console with the pipeline, you should eventually see something like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ strace --output log.txt -s0 -e write -- python3 ./write2.py | python3 ./slow_reader.py
</span></span><span style="display:flex;"><span>start sleeping
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1791</span>
</span></span><span style="display:flex;"><span>generated
</span></span><span style="display:flex;"><span>signal <span style="color:#ae81ff">10</span> &lt;frame at 0x7f59b135da40, file <span style="color:#e6db74">&#39;/home/vagrant/data/blog/post2/./write2.py&#39;</span>, line 15, code &lt;module&gt;&gt;
</span></span><span style="display:flex;"><span>written: <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>stop sleeping
</span></span><span style="display:flex;"><span>finished reading
</span></span></code></pre></div><p>The writer received the signal and exited. It also printed that it had successfully transferred only 65536 bytes (doesn&rsquo;t look familiar?).</p>
<p>The console with the <code>bpftrace</code> confirms the above. The <code>pipe_write()</code> syscall managed to write only 64KiB of data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo bpftrace -e <span style="color:#e6db74">&#39;kretfunc:pipe_write /comm == &#34;python3&#34;/  { printf(&#34;%d\n&#34;, retval);}&#39;</span>
</span></span><span style="display:flex;"><span>Attaching <span style="color:#ae81ff">1</span> probe...
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">65536</span>
</span></span></code></pre></div><p>The <code>strace</code> log shows the same:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat log.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;&#34;</span>..., 536870912<span style="color:#f92672">)</span>           	<span style="color:#f92672">=</span> <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>--- SIGUSR1 <span style="color:#f92672">{</span>si_signo<span style="color:#f92672">=</span>SIGUSR1, si_code<span style="color:#f92672">=</span>SI_USER, si_pid<span style="color:#f92672">=</span>806, si_uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">}</span> ---
</span></span></code></pre></div><p>It looks like it is not sufficient to have only one syscall. If we now open the  <code>write()</code> syscall documentation (<code><a href="https://man7.org/linux/man-pages/man2/write.2.html" target="_blank" rel="noopener">man 2 write</a></code>):</p>
<p><blockquote class="book-hint info">
  Note that a successful write() <strong>may transfer fewer than count bytes</strong>.  Such <strong>partial writes</strong> can occur for various reasons; for example, because there was insufficient space on the disk device to write all of the requested bytes, or because <strong>a blocked write() to</strong> a socket, <strong>pipe</strong>, or similar <strong>was interrupted by a signal handler after it had transferred some, but before it had transferred all of the requested bytes</strong>. In the event of a partial write, the caller can make another write() call to transfer the remaining bytes. The subsequent call will either transfer further bytes or may result in an error (e.g., if the disk is now full).
</blockquote>

The documentation answers our initial question, but there is something, even more, to show here.</p>
<p>As we saw, the <code>pipe_write()</code> function can also return the <code>ERESTARTSYS</code> error if no bytes are written. It is an interesting case, and the kernel can be asked to restart such syscalls automatically without any userspace retries. It makes total sense; the syscall didn’t have any chances to do its work, so the state is the same. The configuration of the kernel restart is done by setting the <code>SA_RESTART</code> flag.  By default, it is already enabled in <code>python</code>. You can check it with the <code>strace</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>rt_sigaction<span style="color:#f92672">(</span>SIGUSR1, <span style="color:#f92672">{</span>sa_handler<span style="color:#f92672">=</span>0x45c680, sa_mask<span style="color:#f92672">=</span>~<span style="color:#f92672">[]</span>, sa_flags<span style="color:#f92672">=</span>SA_RESTORER|SA_ONSTACK|SA_RESTART|SA_SIGINFO, sa_restorer<span style="color:#f92672">=</span>0x45c7c0<span style="color:#f92672">}</span>, NULL, 8<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><p>Now we are finished with all the theory and experiments. But still have the task unresolved. What is the recommended way to write such big buffers into a pipe? We can find the answer in the <code>python</code> source code and its <a href="https://github.com/python/cpython/blob/6e33ba114ffb47505fec59674c5cce5eb6476f76/Lib/_pyio.py#L1285" target="_blank" rel="noopener">buffer writer</a> implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_flush_unlocked</span>(self):
</span></span><span style="display:flex;"><span>   <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">while</span> self<span style="color:#f92672">.</span>_write_buf:
</span></span><span style="display:flex;"><span>      <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>      n <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>raw<span style="color:#f92672">.</span>write(self<span style="color:#f92672">.</span>_write_buf)
</span></span><span style="display:flex;"><span>      <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">del</span> self<span style="color:#f92672">.</span>_write_buf[:n]
</span></span></code></pre></div><p>The above snippet shows how python restarts the <code>write()</code> syscall in case of a partial write.</p>
<p>Now let’s rewrite our producer to use a buffered writer and demonstrate two restart concepts:</p>
<ul>
<li>the automatic syscall restart;</li>
<li>the restart after a partial write.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> signal
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> sys
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> os
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">signal_handler</span>(signum, frame):
</span></span><span style="display:flex;"><span>   print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;signal </span><span style="color:#e6db74">{</span>signum<span style="color:#e6db74">}</span><span style="color:#e6db74"> </span><span style="color:#e6db74">{</span>frame<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> ,file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>signal<span style="color:#f92672">.</span>signal(signal<span style="color:#f92672">.</span>SIGUSR1, signal_handler)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(os<span style="color:#f92672">.</span>getpid(), file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rand <span style="color:#f92672">=</span> os<span style="color:#f92672">.</span>getrandom(<span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">29</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;generated&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> sys<span style="color:#f92672">.</span>stdout<span style="color:#f92672">.</span>buffer<span style="color:#f92672">.</span>write(rand)  <span style="color:#75715e"># &lt;------------------- changed</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;written: </span><span style="color:#e6db74">{</span>n<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, file<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stderr)
</span></span></code></pre></div><p>Start a pipeline:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ strace --output log.txt -s0 -e write -- python3 ./write2.py | python3 ./slow_reader.py
</span></span><span style="display:flex;"><span>start sleeping
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19058</span>
</span></span><span style="display:flex;"><span>generated
</span></span></code></pre></div><p>This time let’s send 4 signals:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ kill -USR1 <span style="color:#ae81ff">19058</span>
</span></span><span style="display:flex;"><span>$ kill -USR1 <span style="color:#ae81ff">19058</span>
</span></span><span style="display:flex;"><span>$ kill -USR1 <span style="color:#ae81ff">19058</span>
</span></span><span style="display:flex;"><span>$ kill -USR1 <span style="color:#ae81ff">19058</span>
</span></span></code></pre></div><p>The output has changed. Now the writer was able to write all the data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ strace --output log.txt -s0 -e write -- python3 ./write2.py | python3 ./slow_reader.py
</span></span><span style="display:flex;"><span>start sleeping
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">19058</span>
</span></span><span style="display:flex;"><span>generated
</span></span><span style="display:flex;"><span>signal <span style="color:#ae81ff">10</span> &lt;frame at 0x7f21a4705a40, file <span style="color:#e6db74">&#39;./write2.py&#39;</span>, line 15, code &lt;module&gt;&gt;
</span></span><span style="display:flex;"><span>signal <span style="color:#ae81ff">10</span> &lt;frame at 0x7f21a4705a40, file <span style="color:#e6db74">&#39;./write2.py&#39;</span>, line 15, code &lt;module&gt;&gt;
</span></span><span style="display:flex;"><span>signal <span style="color:#ae81ff">10</span> &lt;frame at 0x7f21a4705a40, file <span style="color:#e6db74">&#39;./write2.py&#39;</span>, line 15, code &lt;module&gt;&gt;
</span></span><span style="display:flex;"><span>signal <span style="color:#ae81ff">10</span> &lt;frame at 0x7f21a4705a40, file <span style="color:#e6db74">&#39;./write2.py&#39;</span>, line 15, code &lt;module&gt;&gt;
</span></span><span style="display:flex;"><span>stop sleeping
</span></span><span style="display:flex;"><span>written: <span style="color:#ae81ff">536870912</span>
</span></span><span style="display:flex;"><span>finished reading
</span></span></code></pre></div><p>The <code>bpftrace</code> logs show what we expected. For the first write we see the default pipe buffer size, next we see three <code>ERESTARTSYS</code> errors which reflect our 4 signals, and a final big write with all remaining data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ sudo bpftrace -e <span style="color:#e6db74">&#39;kretfunc:pipe_write /comm == &#34;python3&#34;/  { printf(&#34;%d\n&#34;, retval);}&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>-512
</span></span><span style="display:flex;"><span>-512
</span></span><span style="display:flex;"><span>-512
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">536805376</span>
</span></span></code></pre></div><p>In <code>strace</code> log we can also see the information on syscall restarts,  and  it confirms what we saw in <code>bpftrace</code> log.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat log.txt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;&#34;</span>..., 536870912<span style="color:#f92672">)</span>           	<span style="color:#f92672">=</span> <span style="color:#ae81ff">65536</span>
</span></span><span style="display:flex;"><span>--- SIGUSR1 <span style="color:#f92672">{</span>si_signo<span style="color:#f92672">=</span>SIGUSR1, si_code<span style="color:#f92672">=</span>SI_USER, si_pid<span style="color:#f92672">=</span>14994, si_uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">}</span> ---
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;&#34;</span>..., 536805376<span style="color:#f92672">)</span>           	<span style="color:#f92672">=</span> ? ERESTARTSYS <span style="color:#f92672">(</span>To be restarted <span style="color:#66d9ef">if</span> SA_RESTART is set<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>--- SIGUSR1 <span style="color:#f92672">{</span>si_signo<span style="color:#f92672">=</span>SIGUSR1, si_code<span style="color:#f92672">=</span>SI_USER, si_pid<span style="color:#f92672">=</span>14994, si_uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">}</span> ---
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;&#34;</span>..., 536805376<span style="color:#f92672">)</span>           	<span style="color:#f92672">=</span> ? ERESTARTSYS <span style="color:#f92672">(</span>To be restarted <span style="color:#66d9ef">if</span> SA_RESTART is set<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>--- SIGUSR1 <span style="color:#f92672">{</span>si_signo<span style="color:#f92672">=</span>SIGUSR1, si_code<span style="color:#f92672">=</span>SI_USER, si_pid<span style="color:#f92672">=</span>14994, si_uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">}</span> ---
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;&#34;</span>..., 536805376<span style="color:#f92672">)</span>           	<span style="color:#f92672">=</span> ? ERESTARTSYS <span style="color:#f92672">(</span>To be restarted <span style="color:#66d9ef">if</span> SA_RESTART is set<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span>--- SIGUSR1 <span style="color:#f92672">{</span>si_signo<span style="color:#f92672">=</span>SIGUSR1, si_code<span style="color:#f92672">=</span>SI_USER, si_pid<span style="color:#f92672">=</span>14994, si_uid<span style="color:#f92672">=</span>1000<span style="color:#f92672">}</span> ---
</span></span><span style="display:flex;"><span>write<span style="color:#f92672">(</span>1, <span style="color:#e6db74">&#34;&#34;</span>..., 536805376<span style="color:#f92672">)</span>           	<span style="color:#f92672">=</span> <span style="color:#ae81ff">536805376</span>
</span></span></code></pre></div><p>Also, if we sum the returns of the <code>write()</code> syscalls, we’ll get the initial random bytes buffer:</p>
<pre tabindex="0"><code>536805376 + 65536 = 536870912
</code></pre><p>The first <code>write()</code> restart was done by the <code>python</code> buffered writer due to a partial write of 64KiB, and all other 3 were restarted by the kernel due to the <code>ERESTARTSYS</code> error and the <code>SA_RESTART</code> flag.</p>
<h2 id="pipe-performance-splice-vmsplice-and-tee">
  Pipe performance: splice(), vmsplice() and tee()
  <a class="anchor" href="#pipe-performance-splice-vmsplice-and-tee">#</a>
</h2>
<p>Generally, it uses double buffering when a program makes <code>reads()</code>/<code>writes()</code> calls to a regular file, a socket or a pipe. One buffer is allocated in the user space and then copied to the kernel. Such a situation leads to the loss of performance and undesirable memory allocations. Another potential performance penalty for high-performance tools is the number and duration of system calls for one unit of program iteration. For instance, if we want to replace every 2nd line of a file, we need to read the file in some chunks (1 <code>read()</code> syscall), make changes, and write the changed buffer back (1 <code>write()</code> syscall). These sequences of operations should be while we don&rsquo;t reach the <code>EOF</code>.</p>
<p>But luckily,  there are 3 syscalls that can significantly improve your code, especially if you are going to use <code>stdin</code> or <code>stdout</code>:</p>
<ul>
<li><code>splice()</code> – moves data from the buffer to an arbitrary file descriptor, or vice versa, or from one buffer to another (<code><a href="https://man7.org/linux/man-pages/man2/splice.2.html" target="_blank" rel="noopener">man 2 splice</a></code>)</li>
<li><code>vmsplice()</code> – &ldquo;copies&rdquo; data from user space into the buffer  (<code><a href="https://man7.org/linux/man-pages/man2/vmsplice.2.html" target="_blank" rel="noopener">man 2 vmsplice</a></code>)</li>
<li><code>tee()</code>  - allocates internal kernel buffer (<code><a href="https://man7.org/linux/man-pages/man2/tee.2.html" target="_blank" rel="noopener">man 2 tee</a></code>)</li>
</ul>
<p>The main idea here is what if we use a pipe not as a channel between 2 or more processes but just as an in-kernel ring buffer? Yes, of course, if you need to work with <code>stdin</code> and <code>stdout</code>, you can get a win-win situation because you don’t have to create an artificial pipe and use your real one.</p>
<p>So, for example, <code>golang</code> uses pipes (or pool of them) in some zero-copy operations between sockets when the <code>io.Copy()</code>/<code>io.CopyN()</code>/<code>io.CopyBuffer()</code>/<code>io.ReaderFrom()</code> are <a href="https://github.com/golang/go/blob/2580d0e08d5e9f979b943758d3c49877fb2324cb/src/internal/poll/splice_linux.go" target="_blank" rel="noopener">called</a>.</p>
<p>So, the usage:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>r,w <span style="color:#f92672">=</span> <span style="color:#a6e22e">pipe</span>() <span style="color:#960050;background-color:#1e0010">#</span> allocate a kernel ring buffer of <span style="color:#ae81ff">64</span>KB size.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> ;; {
</span></span><span style="display:flex;"><span>	n <span style="color:#f92672">=</span> <span style="color:#a6e22e">splice</span>(socket1, w)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> n <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>    	    <span style="color:#66d9ef">break</span> <span style="color:#75715e">// error, need to check it more carefully here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	m <span style="color:#f92672">=</span> <span style="color:#a6e22e">splice</span>(r, socket2)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> m <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>    	    <span style="color:#66d9ef">break</span> <span style="color:#75715e">// error, need to check it more carefully here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> m <span style="color:#f92672">&lt;</span> n {
</span></span><span style="display:flex;"><span>           <span style="color:#75715e">// partial write
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>           <span style="color:#75715e">// need to resend the rest of the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above code is, of course, a pseudo code and doesn&rsquo;t cover interruption errors and partial writes. But the main idea should be clear.</p>
<p>In theory, we can also increase the pipe buffer size, but it depends on the system and the CPU cache size. But in some cases, the bigger buffer might lead to performance degradations. So do your performance tests carefully.</p>
<p>You can also use this approach to copy a file to another place. But there is even a better solution –  the <code>copy_file_range</code> syscall (<code><a href="https://man7.org/linux/man-pages/man2/copy_file_range.2.html" target="_blank" rel="noopener">man 2 copy_file_range</a></code>). This one syscall does all the work for copying a file. As I mentioned earlier, fewer syscalls lead to better performance.</p>
<p><code>vmsplice()</code> is another beast that could be useful when you want to make changes in the user space and then move this memory to the kernel pipe buffer without copying it. The example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>r,w <span style="color:#f92672">=</span> <span style="color:#a6e22e">pipe</span>() <span style="color:#75715e">// allocate a kernel ring buffer of 64KB size.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#a6e22e">read</span>(file, buf) <span style="color:#75715e">// read data from the file into the user space buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">modify_data</span>(buf) <span style="color:#75715e">// apply some business logic to the data chunk
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>m <span style="color:#f92672">=</span> <span style="color:#a6e22e">vmsplice</span>(w, buf) <span style="color:#75715e">// transfer buffer to the kernel buffer
</span></span></span></code></pre></div><p>The above code is a simplified version of what can be done. But unfortunately, in reality, dealing with <code>vmsplice</code> is complex, and bad documentation doesn&rsquo;t help at all. If you want to go this way, please read the kernel source code first in order to understand all possible problems with <code>vmsplice</code> and zero data coping.</p>
<p>The last syscall that we have is tee(). It’s usually used with splice(). You probably know about the tee cli tool. (<code><a href="https://man7.org/linux/man-pages/man1/tee.1.html" target="_blank" rel="noopener">man 1 tee</a></code>). The purpose of the util is to copy data from one pipe to another one while duplicating the data to a file.  The coreutils implementation of <code><a href="https://github.com/coreutils/coreutils/blob/master/src/tee.c" target="_blank" rel="noopener">tee</a></code> uses <code>read()</code> and <code>write()</code> system calls to work with the pipes. But we are going to write our own version with 2 pretty new syscalls: <code>tee()</code> and <code>splice()</code> instead.</p>
<p>The <code>tee()</code>system call &ldquo;copies&rdquo; data from one buffer (pipe) to another. In reality, no real coping happens. Under the hood, the kernel just changes buffer references for pipe memory. Thus, <code>tee()</code> syscall does not consume any data, so the subsequent <code>splice()</code> call can get this data from a pipe.</p>
<p>So our homebrew implementation could be the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>   <span style="color:#e6db74">&#34;syscall&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> (
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">SPLICE_F_MOVE</span>     = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">SPLICE_F_NONBLOCK</span> = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">file_path</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Args</span>[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;pid:&#34;</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">Getpid</span>())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#a6e22e">file</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">OpenFile</span>(<span style="color:#a6e22e">file_path</span>, <span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">O_RDWR</span>|<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">O_CREATE</span>|<span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">O_TRUNC</span>, <span style="color:#ae81ff">0755</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>       panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>       <span style="color:#a6e22e">n</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Tee</span>(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&lt;&lt;</span><span style="color:#ae81ff">32</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#a6e22e">SPLICE_F_NONBLOCK</span>)
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">EAGAIN</span> {
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">continue</span>
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>           panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>       <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">n</span> &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>           <span style="color:#a6e22e">slen</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">syscall</span>.<span style="color:#a6e22e">Splice</span>(<span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">nil</span>, int(<span style="color:#a6e22e">file</span>.<span style="color:#a6e22e">Fd</span>()), <span style="color:#66d9ef">nil</span>, int(<span style="color:#a6e22e">n</span>), <span style="color:#a6e22e">SPLICE_F_MOVE</span>)
</span></span><span style="display:flex;"><span>           <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>               panic(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>           }
</span></span><span style="display:flex;"><span>           <span style="color:#a6e22e">n</span> <span style="color:#f92672">-=</span> <span style="color:#a6e22e">slen</span>
</span></span><span style="display:flex;"><span>       }
</span></span><span style="display:flex;"><span>   }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let’s test it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat /var/tmp/file1.db |./tee /tmp/tee.log | strings | grep -E <span style="color:#e6db74">&#34;^ss1&#34;</span>
</span></span><span style="display:flex;"><span>ss1T
</span></span><span style="display:flex;"><span>ss1vg
</span></span><span style="display:flex;"><span>ss1j1;
</span></span><span style="display:flex;"><span>ss1*
</span></span></code></pre></div><p>And verify that the file are identical with <code>md5sum</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ md5sum /var/tmp/file1.db
</span></span><span style="display:flex;"><span>737f4f46feed57b4c6bdde840945948e  /var/tmp/file1.db
</span></span><span style="display:flex;"><span>$ md5sum /tmp/tee.log
</span></span><span style="display:flex;"><span>737f4f46feed57b4c6bdde840945948e  /tmp/tee.log
</span></span></code></pre></div><p>And a final note, I would suggest reading the archive of Linus’s emails about <code>splice()</code>, <code>tee()</code> and <code>vmsplice()</code> here <a href="https://yarchive.net/comp/linux/splice.html" target="_blank" rel="noopener">https://yarchive.net/comp/linux/splice.html</a>. You can find there a lot of design questions and solution for all these syscalls.</p>




  

<a  href="/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/"   class="book-btn right-button">
  Read next chapter →
</a>

</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>




 
        <script defer src="/my_js/copy-code.js"></script>

      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
  </main>

  
<div class="cookie-container">
    <p>
        This website uses "<b>cookies</b>".
        Using this website means you're OK with this.
        If you are <b>NOT</b>, please close the site page.
    </p>
    <button class="cookie-btn">
        ACCEPT AND CLOSE
    </button>
</div>
<script src="/my_js/cookie.js"></script>
</body>
</html>












