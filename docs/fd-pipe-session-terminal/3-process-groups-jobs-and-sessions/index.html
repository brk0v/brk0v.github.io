<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Process groups, jobs and sessions # A new process group is created every time we execute a command or a pipeline of commands in a shell. Inside a shell, a process group is usually called a job. In its turn, each process group belongs to a session. Linux kernel provides a two-level hierarchy for all running processes (look at Image 3 below). As such, a process group is a set of processes, and a session is a set of related process groups."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Process groups, jobs and sessions"><meta property="og:description" content="Process groups, jobs and sessions # A new process group is created every time we execute a command or a pipeline of commands in a shell. Inside a shell, a process group is usually called a job. In its turn, each process group belongs to a session. Linux kernel provides a two-level hierarchy for all running processes (look at Image 3 below). As such, a process group is a set of processes, and a session is a set of related process groups."><meta property="og:type" content="article"><meta property="og:url" content="https://biriukov.dev/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/"><meta property="article:section" content="docs"><title>Process groups, jobs and sessions | Viacheslav Biriukov</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.82c5dbd23447cee0b4c2aa3ed08ce0961faa40e1fa370eee4f8c9f02e0d46b5f.css integrity="sha256-gsXb0jRHzuC0wqo+0Izglh+qQOH6Nw7uT4yfAuDUa18=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.8407ffc2ee2272b03b282a0175eec84a1abc9b7522eec8fd061e8bf4af45498d.js integrity="sha256-hAf/wu4icrA7KCoBde7IShq8m3Ui7sj9Bh6L9K9FSY0=" crossorigin=anonymous></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-599VSLESJL"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-599VSLESJL")</script><link rel=stylesheet href=/my_css/cookie.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap-icons@1.5.0/font/bootstrap-icons.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Viacheslav Biriukov</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><span>GNU/Linux shell related internals</span><ul><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/>0. GNU/Linux shell related internals for SRE</a></li><li><a href=/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/>1. File descriptor and open file description</a></li><li><a href=/docs/fd-pipe-session-terminal/2-pipes/>2. Pipes</a></li><li><a href=/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/ class=active>3. Process groups, jobs and sessions</a></li><li><a href=/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/>4. Terminals and pseudoterminals</a></li></ul></li></ul><div style=margin-top:30px;margin-bottom:30px><b>More post series:</b><ul><li><a href=/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons>1. File descriptors, pipes, terminals, user sessions, process groups and daemons <span style="padding:0 2px;border-radius:2px;background-color:#e84118;color:#f0f8ff">new</span></li><li><a href=/docs/page-cache/0-linux-page-cache-for-sre/>2. Linux Page Cache mini book</li></ul></div><ul><li><a href=https://twitter.com/brk0v/ target=_blank rel=noopener><i class="bi bi-twitter"></i>
Twitter</a></li><li><a href=https://fosstodon.org/@brk0v target=_blank rel=noopener><i class="bi bi-mastodon"></i>
Mastodon</a></li><li><a href=https://www.linkedin.com/in/biriukov/ target=_blank rel=noopener><i class="bi bi-linkedin"></i>
Linkedin</a></li><li><a href=https://github.com/brk0v/ target=_blank rel=noopener><i class="bi bi-github"></i>
Github</a></li></ul><div style=margin-top:30px><p xmlns:cc=http://creativecommons.org/ns#>This content is licensed under
<a href="http://creativecommons.org/licenses/by-nc/4.0/?ref=chooser-v1" target=_blank rel="license noopener noreferrer" style=display:inline-block>CC BY-NC 4.0<img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1"><img style=height:22px!important;margin-left:3px;vertical-align:text-bottom src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1"></a></p></div></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Process groups, jobs and sessions</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#process-groups-jobs-and-sessions>Process groups, jobs and sessions</a><ul><li><a href=#process-groups>Process groups</a></li><li><a href=#sessions>Sessions</a></li><li><a href=#controlling-terminal-controlling-process-foreground-and-background-process-groups>Controlling terminal, controlling process, foreground and background process groups</a></li><li><a href=#shell-job-control>Shell job control</a></li><li><a href=#kill-command><code>kill</code> command</a></li><li><a href=#terminating-shell>Terminating shell</a></li><li><a href=#nohup-and-disown><code>nohup</code> and <code>disown</code></a></li><li><a href=#daemons>Daemons</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=process-groups-jobs-and-sessions>Process groups, jobs and sessions
<a class=anchor href=#process-groups-jobs-and-sessions>#</a></h1><p>A new process group is created every time we execute a command or a pipeline of commands in a shell. Inside a shell, a <strong>process group</strong> is usually called a <strong>job</strong>. In its turn, each process group belongs to a session. Linux kernel provides a <strong>two-level hierarchy</strong> for all running processes (look at Image 3 below). As such, a process group is a set of processes, and a session is a set of related process groups. Another important limitation is that a process group and its members can be members of a single session.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sleep <span style=color:#ae81ff>100</span>  <span style=color:#75715e># a process group with 1 process</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ cat /var/log/nginx.log | grep string | head <span style=color:#75715e>#  a process group with 3 processes </span>
</span></span></code></pre></div><h2 id=process-groups>Process groups
<a class=anchor href=#process-groups>#</a></h2><p>A process group has its process group identificator <code>PGID</code> and a leader who created this group. The <code>PID</code> of the group leader is equal to the corresponding <code>PGID</code>. As so, the type of <code>PID</code> and <code>PGID</code> are the same, and is (<code>pid_t</code>)[https://ftp.gnu.org/old-gnu/Manuals/glibc-2.2.3/html_node/libc_554.html]. All new processes created by the group members inherit the <code>PGID</code> and become the process group members. In order to create a group, we have <code>setpgid()</code> and <code>setpgrp()</code> syscalls (<code><a href=https://man7.org/linux/man-pages/man2/getpgrp.2. target=_blank rel=noopener>man 2 getpgrp()</a></code>).</p><p>A process group lives as long as it has at least one member. It means that even if the group leader terminates, the process group is valid and continues carrying out its duties. A process can leave its process group by:</p><ul><li>joining another group;</li><li>creating its own new group;</li><li>terminating.</li></ul><p>Linux kernel can reuse <code>PID</code>s for new processes if only the process group with that <code>PGID</code> doesn’t have members. It secures a valid hierarchy of processes.</p><p>A leader of a process group can’t join another process group because the constraints between <code>PID</code> of the process and <code>PGID</code> of the members of the group will be violated.</p><p>Two interesting features of process groups are:</p><ol><li>a parent process can <code>wait()</code> for its children using the process group id;</li><li>a signal can be sent to all members of a process group by using <code>killpg()</code> or <code>kill()</code> with a negative <code>PGID</code> parameter.</li></ol><p>The below command sends a <code>SIGTERM(15)</code> to all members of the process group 123:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kill -15 -123  
</span></span></code></pre></div><p>The following 2 scripts demonstrate this feature. We have 2 long-running scripts in a process group (it was created for us automatically by shell) connected by a pipe.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>print.py
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> signal
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>signal_handler</span>(signum, frame):
</span></span><span style=display:flex><span>	print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[print] signal number: </span><span style=color:#e6db74>{</span>signum<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>, file<span style=color:#f92672>=</span>sys<span style=color:#f92672>.</span>stderr)
</span></span><span style=display:flex><span>	os<span style=color:#f92672>.</span>_exit(signum)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGTERM, signal_handler)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;PGID: </span><span style=color:#e6db74>{</span>os<span style=color:#f92672>.</span>getpgrp()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>, file<span style=color:#f92672>=</span>sys<span style=color:#f92672>.</span>stderr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>9999</span>):
</span></span><span style=display:flex><span>	print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>	sys<span style=color:#f92672>.</span>stdout<span style=color:#f92672>.</span>flush()
</span></span><span style=display:flex><span>	time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>and</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>stdin.py
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> fileinput
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> signal
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> sys
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>signal_handler</span>(signum, frame):
</span></span><span style=display:flex><span>	print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;[stdin] signal number: </span><span style=color:#e6db74>{</span>signum<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>, file<span style=color:#f92672>=</span>sys<span style=color:#f92672>.</span>stderr)
</span></span><span style=display:flex><span>	os<span style=color:#f92672>.</span>_exit(signum)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGTERM, signal_handler)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i, line <span style=color:#f92672>in</span> enumerate(fileinput<span style=color:#f92672>.</span>input()):
</span></span><span style=display:flex><span>	print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>i<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span><span style=color:#e6db74>}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{</span>line<span style=color:#f92672>.</span>rstrip()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>Start the pipeline, and in the middle of the execution, run a <code>kill</code> command in a new terminal window.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 ./print.py | python3 ./stdin.py
</span></span><span style=display:flex><span>PGID: <span style=color:#ae81ff>9743</span>
</span></span><span style=display:flex><span>1: <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>2: <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>3: <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>4: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>stdin<span style=color:#f92672>]</span> signal number: <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>print<span style=color:#f92672>]</span> signal number: <span style=color:#ae81ff>15</span>
</span></span></code></pre></div><p>And kill it by specifying the <code>PGID</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kill -15 -9743
</span></span></code></pre></div><h2 id=sessions>Sessions
<a class=anchor href=#sessions>#</a></h2><p>For its part, a session is a collection of process groups. All members of a session identify themselves by the identical <code>SID</code>. It’s also the <code>pid_t</code> type, and as a process group, also inherited from the session leader, which created the session. All processes in the session share a single controlling terminal (we’ll talk about this later).</p><p>A new process inherits its parent’s session ID. In order to start a new session a process should call <code>setsid()</code> (<code><a href=https://man7.org/linux/man-pages/man2/setsid.2.html target=_blank rel=noopener>man 2 setsid</a></code>). The process running this syscall begins a new session, becomes its leader, starts a new process group, and becomes its leader too. <code>SID</code> and <code>PGID</code> are set to the process’ <code>PID</code>. That’s why the process group leader can’t start a new session: the process group could have members, and all these members must be in the same session.</p><p>Basically, a new session is created in two cases:</p><ol><li>When we need to log in a user with an interactive shell. A shell process becomes a session leader with a controlling terminal (about this later).</li><li>A daemon starts and wants to run in its own session in order to secure itself (we will touch daemons in more detail later).</li></ol><p>The following image shows a relationship between a session, its process groups and processes.</p><img alt="2 level hierarchy of processes" src=../images/process-group-session.png class=img-center><div class=text-center>Image 3. – 2 level hierarchy of processes</div><ul><li>❶ – Session id (<code>SID</code>) is the same as the session leader process (<code>bash</code>) <code>PID</code>.</li><li>❷ – The session leader process (<code>bash</code>) has its own process group, where it’s a leader, so <code>PGID</code> is the same as its <code>PID.</code></li><li>❸, ❹ – The session has 2 more process groups with <code>PGID</code>s 200 and 300.</li><li>❺, ❻ – Only one group can be a foreground for a terminal. All other process groups are background. We will touch on these terms in a minute.</li><li>❼, ❽, ❾ – All members of a session share a pseudoterminal <code>/dev/pts/0</code>.</li></ul><p>In order to get all the above information for a running process, we can read the <code>/proc/$PID/stat</code> file. For example, for my running bash shell <code>$$</code> porcess:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/$$/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid 	<span style=color:#ae81ff>8415</span>  <span style=color:#75715e># PID</span>
</span></span><span style=display:flex><span>ppid	<span style=color:#ae81ff>8414</span>  <span style=color:#75715e># parent PID</span>
</span></span><span style=display:flex><span>pgid	<span style=color:#ae81ff>8415</span>  <span style=color:#75715e># process group ID</span>
</span></span><span style=display:flex><span>sid 	<span style=color:#ae81ff>8415</span>  <span style=color:#75715e># sessions ID</span>
</span></span><span style=display:flex><span>tty 	<span style=color:#ae81ff>34816</span> <span style=color:#75715e># tty number</span>
</span></span><span style=display:flex><span>tgid	<span style=color:#ae81ff>9348</span>  <span style=color:#75715e># foreground process group ID</span>
</span></span></code></pre></div><p>where (man 5 procfs <a href=https://man7.org/linux/man-pages/man5/proc.5.html%29 target=_blank rel=noopener>https://man7.org/linux/man-pages/man5/proc.5.html)</a>:</p><ul><li><code>pid</code> – the process id.</li><li><code>ppid</code> – the <code>PID</code> of the parent of this process.</li><li><code>pgrp</code> – the process group id of the process.</li><li><code>sid</code> – the session id of the process.</li><li><code>tty</code> – the controlling terminal of the process. (The minor device number is contained in the combination of bits 31 to 20 and 7 to 0; the major device number is in bits 15 to 8.)</li><li><code>tgid</code> – the id of the foreground process group of the controlling terminal of the process.</li></ul><h2 id=controlling-terminal-controlling-process-foreground-and-background-process-groups>Controlling terminal, controlling process, foreground and background process groups
<a class=anchor href=#controlling-terminal-controlling-process-foreground-and-background-process-groups>#</a></h2><p>A controlling terminal is a terminal (<code>tty</code>, <code>pty</code>, <code>console</code>, etc) that controls a session. There may not be a controlling terminal for a session. It is usual for daemons.</p><p>In order to create a controlling terminal, at first, the session leader (usually a shell process) starts a new session with <code>setsid()</code>. This action drops a previously available terminal if it exists. Then the process needs to open a terminal device. On this first <code>open()</code> call, the target terminal becomes the controlling terminal for the session. From this point in time, all existing processes in the session are able to use the terminal too. The controlling terminal is inherited by <code>fork()</code> call and preserved by <code>execve()</code>. A particular terminal can be the controlling terminal only for one session.</p><p>A controlling terminal sets 2 important definitions: a <strong>foreground process group</strong> and a <strong>background process group</strong>. At any moment, there can be only <strong>one</strong> foreground process group for the session and <strong>any number</strong> of background ones. Only processes in the foreground process group can read from the controlling terminal. On the other hand, writes are allowed from any process by default. There are some tricks with terminals, we touch them later, when we will talk solely about terminals.</p><p>A terminal user can type special signal-generating terminal characters on the controlling terminal. The most famous ones are <code>CTRL+C</code> and <code>CTRL+Z</code>. As its name suggests, a corresponding signal is sent to the <strong>foreground</strong> process group. By default, the <code>CTRL+C</code> triggers a <code>SIGINT</code> signal, and <code>CTRL+Z</code> a <code>SIGTSTP</code> signal.</p><p>Also, opening the controlling terminal makes the session leader <strong>the controlling process of the terminal</strong>. Starting from this moment, if a terminal disconnection occurs, the kernel will send a <code>SIGHUP</code> signal to the session leader (usually a shell process).</p><p>The <code>tcsetpgrp()</code> (<a href=https://man7.org/linux/man-pages/man3/tcsetpgrp.3.html target=_blank rel=noopener><code>man 3 tcsetpgrp</code></a>) is a <code>libc</code> function to promote a process group to the foreground group of the controlling terminal. There is also the <code>tcgetpgrp()</code> function to get the current foreground group. These functions are used primarily by shells in order to control jobs. On linux, we can also use <code>ioctl()</code> with <code>TIOCGPGRP</code> and <code>TIOCSPGRP</code> operations to get and set the foreground group.</p><p>Let&rsquo;s write a script that emulates the shell logic of creating a process group for a pipeline.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>pg.py
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;parent: </span><span style=color:#e6db74>{</span>os<span style=color:#f92672>.</span>getpid()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>pgpid <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>fork()  <span style=color:#75715e># ⓵</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> pgpid:
</span></span><span style=display:flex><span>   <span style=color:#75715e># child</span>
</span></span><span style=display:flex><span>   os<span style=color:#f92672>.</span>setpgid(os<span style=color:#f92672>.</span>getpid(), os<span style=color:#f92672>.</span>getpid())  <span style=color:#75715e># ⓶</span>
</span></span><span style=display:flex><span>   os<span style=color:#f92672>.</span>execve(<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, [<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, ], os<span style=color:#f92672>.</span>environ)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;pgid: </span><span style=color:#e6db74>{</span>pgpid<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pid <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>fork()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> pid:
</span></span><span style=display:flex><span>  <span style=color:#75715e># child</span>
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>setpgid(os<span style=color:#f92672>.</span>getpid(), pgpid)  <span style=color:#75715e># ⓷</span>
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>execve(<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, [<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, ], os<span style=color:#f92672>.</span>environ)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pid <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>fork()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> pid:
</span></span><span style=display:flex><span>  <span style=color:#75715e># child</span>
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>setpgid(os<span style=color:#f92672>.</span>getpid(), pgpid)  <span style=color:#75715e># ⓷</span>
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>execve(<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, [<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, ], os<span style=color:#f92672>.</span>environ)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>) :
</span></span><span style=display:flex><span>  pid, status <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>waitpid(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>)
</span></span></code></pre></div><p>⓵ – Create the first process in the shell pipeline.</p><p>⓶ – Start a new process group and store its <code>PID</code> as a new <code>PGID</code> for all future processes.</p><p>⓷ – Start new processes and move them into the process group with <code>PGID.</code></p><p>So when we run it we can see the following output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>python3 ./pg.py
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parent: <span style=color:#ae81ff>8429</span>
</span></span><span style=display:flex><span>pgid: <span style=color:#ae81ff>8430</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>8431</span> sleep
</span></span><span style=display:flex><span><span style=color:#ae81ff>8432</span> sleep
</span></span><span style=display:flex><span><span style=color:#ae81ff>8430</span> sleep
</span></span></code></pre></div><p>The full state of processes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/8429/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid   	<span style=color:#ae81ff>8429</span>
</span></span><span style=display:flex><span>ppid    <span style=color:#ae81ff>8415</span>
</span></span><span style=display:flex><span>pgid    <span style=color:#ae81ff>8429</span>
</span></span><span style=display:flex><span>sid   	<span style=color:#ae81ff>8415</span>
</span></span><span style=display:flex><span>tty   	<span style=color:#ae81ff>34816</span>
</span></span><span style=display:flex><span>tgid    <span style=color:#ae81ff>8429</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/8430/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid   	<span style=color:#ae81ff>8430</span>
</span></span><span style=display:flex><span>ppid    <span style=color:#ae81ff>8429</span>
</span></span><span style=display:flex><span>pgid    <span style=color:#ae81ff>8430</span>
</span></span><span style=display:flex><span>sid   	<span style=color:#ae81ff>8415</span>
</span></span><span style=display:flex><span>tty   	<span style=color:#ae81ff>34816</span>
</span></span><span style=display:flex><span>tgid    <span style=color:#ae81ff>8429</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/8431/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid   	<span style=color:#ae81ff>8431</span>
</span></span><span style=display:flex><span>ppid    <span style=color:#ae81ff>8429</span>
</span></span><span style=display:flex><span>pgid    <span style=color:#ae81ff>843</span>
</span></span><span style=display:flex><span>sid   	<span style=color:#ae81ff>8415</span>
</span></span><span style=display:flex><span>tty   	<span style=color:#ae81ff>34816</span>
</span></span><span style=display:flex><span>tgid    <span style=color:#ae81ff>8429</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/8432/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid   	<span style=color:#ae81ff>8432</span>
</span></span><span style=display:flex><span>ppid    <span style=color:#ae81ff>8429</span>
</span></span><span style=display:flex><span>pgid    <span style=color:#ae81ff>8430</span>
</span></span><span style=display:flex><span>sid   	<span style=color:#ae81ff>8415</span>
</span></span><span style=display:flex><span>tty   	<span style=color:#ae81ff>34816</span>
</span></span><span style=display:flex><span>tgid    <span style=color:#ae81ff>8429</span>
</span></span></code></pre></div><p>The only problem with the above code is we didn&rsquo;t transfer the foreground group to our newly created process group. The <code>tgid</code> in the above output shows that. The 8429 <code>PID</code> is a <code>PGID</code> of the parent <code>pg.py</code> script, not the newly created process group 8430.</p><p>Now, if we press <code>CTRL+C</code> to terminate the processes, we’ll stop only the parent with <code>PID</code> 8429. It happens because it’s in the foreground group from the perspective of the controlling terminal. All processes in the 8430 group will continue running in the background. If they try to read from the terminal (<code>stdin</code>), they will be stopped by the controlling terminal by sending them a <code>SIGTTIN </code>signal. It is a result of trying to read from the controlling terminal without acquiring the foreground group. If we log out or close the controlling terminal, this group will not get a <code>SIGHUP</code> signal, because the <code>bash</code> process (the controlling process) doesn’t know that we started something in the background.</p><p>In order to fix this situation, we need to notify the controlling terminal that we want to run another process group in the foreground. Let’s modify the code and add the <code>tcsetpgrp()</code> call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> os
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> signal
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;parent: </span><span style=color:#e6db74>{</span>os<span style=color:#f92672>.</span>getpid()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>pgpid <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>fork()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> pgpid:
</span></span><span style=display:flex><span>   <span style=color:#75715e># child</span>
</span></span><span style=display:flex><span>   os<span style=color:#f92672>.</span>setpgid(os<span style=color:#f92672>.</span>getpid(), os<span style=color:#f92672>.</span>getpid())
</span></span><span style=display:flex><span>   os<span style=color:#f92672>.</span>execve(<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, [<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, ], os<span style=color:#f92672>.</span>environ)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;pgid: </span><span style=color:#e6db74>{</span>pgpid<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pid <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>fork()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> pid:
</span></span><span style=display:flex><span>  <span style=color:#75715e># child</span>
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>setpgid(os<span style=color:#f92672>.</span>getpid(), pgpid)
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>execve(<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, [<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, ], os<span style=color:#f92672>.</span>environ)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>pid <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>fork()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> pid:
</span></span><span style=display:flex><span>  <span style=color:#75715e># child</span>
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>setpgid(os<span style=color:#f92672>.</span>getpid(), pgpid)
</span></span><span style=display:flex><span>  os<span style=color:#f92672>.</span>execve(<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, [<span style=color:#e6db74>&#34;./sleep.py&#34;</span>, ], os<span style=color:#f92672>.</span>environ)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tty_fd <span style=color:#f92672>=</span> os<span style=color:#f92672>.</span>open(<span style=color:#e6db74>&#34;/dev/tty&#34;</span>, os<span style=color:#f92672>.</span>O_RDONLY)  <span style=color:#75715e># ⓵</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>tcsetpgrp(tty_fd, pgpid)  <span style=color:#75715e># ⓶</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>):  <span style=color:#75715e># ⓷</span>
</span></span><span style=display:flex><span>   os<span style=color:#f92672>.</span>waitpid(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>h <span style=color:#f92672>=</span> signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGTTOU, signal<span style=color:#f92672>.</span>SIG_IGN)  <span style=color:#75715e># ⓸</span>
</span></span><span style=display:flex><span>os<span style=color:#f92672>.</span>tcsetpgrp(tty_fd, os<span style=color:#f92672>.</span>getpgrp())  <span style=color:#75715e># ⓹</span>
</span></span><span style=display:flex><span>signal<span style=color:#f92672>.</span>signal(signal<span style=color:#f92672>.</span>SIGTTOU, h)  <span style=color:#75715e># ⓺</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>&#34;got foreground back&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>time<span style=color:#f92672>.</span>sleep(<span style=color:#ae81ff>99999</span>)
</span></span></code></pre></div><p>⓵ – In order to run the <code>tcsetpgrp()</code>, we need to know the current controlling terminal path. The safest way to do that is to open a special virtual file <code>/dev/tty</code>. If a process has a controlling terminal, it returns a file descriptor for that terminal. We, in theory, can use one of the standard file descriptors too. But it&rsquo;s not sustanable because the caller can redirects all of them.</p><p>⓶ – Put the new process group into the foreground group of the controlling terminal.</p><p>⓷ – Here, we wait for the processes to exit. It is where we should call <code>CTRL+C</code>.</p><p>⓸ – Before we command the controlling terminal to return into the foreground session we need to silence the <code>SIGTTOU</code> signal. The man page says: If <code>tcsetpgrp()</code> is called by a member of a background process group in its session, and the calling process is not blocking or ignoring <code>SIGTTOU</code>, a <code>SIGTTOU</code> signal is sent to all members of this background process group. We don’t need this signal, so it’s OK to block it.</p><p>⓹ – Returning to the foreground.</p><p>⓺ – Restoring the <code>SIGTTOU</code> signal handler.</p><p>And if we now run the script and press <code>CTRL+C</code>, everything should work as expected.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ python3 ./pg.py
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parent: <span style=color:#ae81ff>8621</span>
</span></span><span style=display:flex><span>pgid: <span style=color:#ae81ff>8622</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>8622</span> sleep
</span></span><span style=display:flex><span><span style=color:#ae81ff>8624</span> sleep
</span></span><span style=display:flex><span><span style=color:#ae81ff>8623</span> sleep
</span></span><span style=display:flex><span>^C                            &lt;------------------- CTRL+C was pressed
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Traceback <span style=color:#f92672>(</span>most recent call last<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>  File <span style=color:#e6db74>&#34;/home/vagrant/data/blog/post2/./sleep.py&#34;</span>, line 7, in &lt;module&gt;
</span></span><span style=display:flex><span>Traceback <span style=color:#f92672>(</span>most recent call last<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>  File <span style=color:#e6db74>&#34;/home/vagrant/data/blog/post2/./sleep.py&#34;</span>, line 7, in &lt;module&gt;
</span></span><span style=display:flex><span>Traceback <span style=color:#f92672>(</span>most recent call last<span style=color:#f92672>)</span>:
</span></span><span style=display:flex><span>  File <span style=color:#e6db74>&#34;/home/vagrant/data/blog/post2/./sleep.py&#34;</span>, line 7, in &lt;module&gt;
</span></span><span style=display:flex><span>	time.sleep<span style=color:#f92672>(</span>99999<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>KeyboardInterrupt
</span></span><span style=display:flex><span>	time.sleep<span style=color:#f92672>(</span>99999<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>KeyboardInterrupt
</span></span><span style=display:flex><span>	time.sleep<span style=color:#f92672>(</span>99999<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>KeyboardInterrupt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>got foreground back            &lt;----------------- back to foreground
</span></span></code></pre></div><h2 id=shell-job-control>Shell job control
<a class=anchor href=#shell-job-control>#</a></h2><p>Now it’s time to understand how shells allow us to run multiple commands simultaneously and how we can control them.</p><p>For instance, when we run the following pipeline:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sleep <span style=color:#ae81ff>999</span> | grep <span style=color:#ae81ff>123</span>
</span></span></code></pre></div><p>The shell here:</p><ul><li>creates a new process group with the <code>PGID</code> of the first process in the group;</li><li>puts this group in the foreground group by notifying the terminal with <code>tcsetpgrp()</code>;</li><li>stores the <code>PID</code>s and sets up a <code>waitpid()</code> syscall.</li></ul><blockquote class="book-hint info">The process group is also known as a shell job.</blockquote><p>The <code>PID</code>s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ps a | grep sleep
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>9367</span> pts/1	S+ 	0:00 sleep <span style=color:#ae81ff>999</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ps a | grep grep
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>9368</span> pts/1	S+ 	0:00 grep <span style=color:#ae81ff>123</span>
</span></span></code></pre></div><p>And if we get the details for <code>sleep</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/9367/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid 	<span style=color:#ae81ff>9367</span>
</span></span><span style=display:flex><span>ppid	<span style=color:#ae81ff>6821</span>
</span></span><span style=display:flex><span>pgid	<span style=color:#ae81ff>9367</span>
</span></span><span style=display:flex><span>sid 	<span style=color:#ae81ff>6821</span>
</span></span><span style=display:flex><span>tty 	<span style=color:#ae81ff>34817</span>
</span></span><span style=display:flex><span>tgid	<span style=color:#ae81ff>9367</span>
</span></span></code></pre></div><p>and for <code>grep</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/9368/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid 	<span style=color:#ae81ff>9368</span>
</span></span><span style=display:flex><span>ppid	<span style=color:#ae81ff>6821</span>
</span></span><span style=display:flex><span>pgid	<span style=color:#ae81ff>9367</span>
</span></span><span style=display:flex><span>sid 	<span style=color:#ae81ff>6821</span>
</span></span><span style=display:flex><span>tty 	<span style=color:#ae81ff>34817</span>
</span></span><span style=display:flex><span>tgid	<span style=color:#ae81ff>9367</span>
</span></span></code></pre></div><p>While waiting for the foreground job to finish, we can move this job to the background by pressing <code>Ctrl+Z</code>. It is a control action for the terminal, which sends a <code>SIGTSTP</code> signal to the foreground process group. The default signal handler for a process is to stop. In its turn, <code>bash</code> gets a notification from the <code>waitpid()</code>, that the statuses of the monitoring processes have changed. When <code>bash</code> sees that the foreground group has become stopped, it returns the foreground back to shell by running <code>tcsetpgrp()</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>^Z
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>+  Stopped             	sleep <span style=color:#ae81ff>999</span> | grep <span style=color:#ae81ff>123</span>
</span></span><span style=display:flex><span>$ 
</span></span></code></pre></div><p>We can get the current statuses of all known jobs by using the built-in <code>jobs</code> command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ jobs -l
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>+  <span style=color:#ae81ff>7962</span> Stopped             	sleep <span style=color:#ae81ff>999</span>
</span></span><span style=display:flex><span>  	  <span style=color:#ae81ff>7963</span>                   	| grep <span style=color:#ae81ff>123</span>
</span></span></code></pre></div><p>We may resume a job in the background by calling <code>bg</code> shell built-in with the ID of the job.When we use <code>bg</code> with a background stopped job, the shell uses <code>killpg</code> and <code>SIGCONT</code> signal.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ bg %1
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>+ sleep <span style=color:#ae81ff>999</span> | grep <span style=color:#ae81ff>123</span> &amp;
</span></span></code></pre></div><p>If we check the status now, we can see that it’s running in the background.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ jobs -l
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>+  <span style=color:#ae81ff>7962</span> Running             	sleep <span style=color:#ae81ff>999</span>
</span></span><span style=display:flex><span>  	<span style=color:#ae81ff>7963</span>                   	| grep <span style=color:#ae81ff>123</span> &amp;
</span></span></code></pre></div><p>If we want, we can move the job back in the foreground by calling <code>fg</code> built-in shell command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ fg %1
</span></span><span style=display:flex><span>sleep <span style=color:#ae81ff>999</span> | grep <span style=color:#ae81ff>123</span>
</span></span></code></pre></div><p>We also can start a job in the background by adding an ampersand (<code>&</code>) char in the end of the pipeline:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ sleep <span style=color:#ae81ff>999</span> | grep <span style=color:#ae81ff>123</span> &amp;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>9408</span>
</span></span><span style=display:flex><span>$
</span></span></code></pre></div><h2 id=kill-command><code>kill</code> command
<a class=anchor href=#kill-command>#</a></h2><p><code>kill</code> is usually a shell built-in for at least two reasons:</p><ol><li>Shell usually allows to kill jobs by their job ids. So we need to be able to resolve internal job IDs into process group IDs (the <code>%job_id</code> syntaxis).</li><li>Allow users to send signals to processes if the system hits the max running process limit. Usually, during emergencies and system misbehaviour.</li></ol><p>For example, we can check how <code>bash</code> does it – <a href=https://github.com/bminor/bash/blob/f3a35a2d601a55f337f8ca02a541f8c033682247/builtins/kill.def#L85 target=_blank rel=noopener><code>int kill_builtin()</code></a> and <code>zsh</code> – <a href=https://github.com/zsh-users/zsh/blob/00d20ed15e18f5af682f0daec140d6b8383c479a/Src/jobs.c#L2589 target=_blank rel=noopener><code>int bin_kill()</code></a>.</p><p>Another helpful piece of knowledge about the <code>kill</code> command and system calls is a &ldquo;<code>-1</code>&rdquo; process group. It&rsquo;s a special group, and the signal to it will fan out the signal to all processes on the system except the <code>PID</code> 1 process (it&rsquo;s almost always a <code>systemd</code> process on all modern GNU/Linux distributions):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span>remote ~<span style=color:#f92672>]</span> $ sudo kill -15 -1
</span></span><span style=display:flex><span>Connection to 192.168.0.1 closed by remote host.
</span></span><span style=display:flex><span>Connection to 192.168.0.1 closed.
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>local ~<span style=color:#f92672>]</span> $ 
</span></span></code></pre></div><h2 id=terminating-shell>Terminating shell
<a class=anchor href=#terminating-shell>#</a></h2><p>When a controlling process loses its terminal connection, the kernel sends a <code>SIGHUP</code> signal to inform it of this fact. If either the controlling process or other members of the session ignores this signal, or handle it and do nothing, then the further read from and write to the closed terminal (ususally <code>/dev/pts/*</code>) calls will return the end-of-file (<code>EOF</code>) zero bytes.</p><p>Shell processes (which are usually control terminals) have a handler to catch <code>SIGHUP</code> signals. Receiving a signal starts a fan-out process of sending <code>SIGHUP </code>signals to all jobs it has created and know about (remember the <code>fg</code>, <code>bg</code> and <code>waitpid()</code>). The default action for the <code>SIGHUP</code> is terminate.</p><h2 id=nohup-and-disown><code>nohup</code> and <code>disown</code>
<a class=anchor href=#nohup-and-disown>#</a></h2><p>But suppose we want to protect our long-running program from being suddenly killed by a broken internet connection or low laptop battery. In that case, we can start a program under <code>nohup</code> tool or use <code>bash</code> job control <code>disown</code>built-in command. Let’s understand how they work and where they are different.</p><p>The <code>nohup</code> performs the following tricks:</p><ol><li>Changes the <code>stdin</code> fd to <code>/dev/null.</code></li><li>Redirects the <code>stdout</code> and <code>stderr</code> to a file on disk.</li><li>Set an ignore <code>SIG_IGN</code> flag for <code>SIGHUP</code> signal. The interesting moment here is that the <code>SIG_IGN</code> is preserved after the <code>execve()</code> syscall.</li><li>Run the <code>execve()</code>.</li></ol><p>All the above make the program immune to the <code>SIGHUP</code> signal and can’t fail due to writing to or reading from the closed terminal.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ nohup ./long_running_script.py &amp;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>9946</span>
</span></span><span style=display:flex><span>$ nohup: ignoring input and appending output to <span style=color:#e6db74>&#39;nohup.out&#39;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ jobs -l
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>+  <span style=color:#ae81ff>9946</span> Running             	nohup ./long_running_script.py &amp;
</span></span></code></pre></div><p>As you can see from the output, the <code>bash</code> knows about this process and can show it in jobs.</p><p>Another way we have to achieve long-running programs to survive the controlling terminal closure is a built-in <code>disown</code> of the <code>bash</code> shell. Instead of ignoring the <code>SIGHUP</code> signal, it just removes the job&rsquo;s <code>PID</code> from the list of known jobs. Thus no <code>SIGHUP</code> signal will be sent to the group.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ./long_running_script.py &amp;
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span> <span style=color:#ae81ff>9949</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ jobs -l
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>1<span style=color:#f92672>]</span>+  <span style=color:#ae81ff>9949</span> Running             	./long_running_script.py &amp;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ disown <span style=color:#ae81ff>9949</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ jobs -l
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ ps a | grep <span style=color:#ae81ff>9949</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>9949</span> pts/0	S  	0:00 /usr/bin/python3 ./long_running_script.py
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>9954</span> pts/0	S+ 	0:00 grep <span style=color:#ae81ff>9949</span>
</span></span></code></pre></div><p>The drawback of the above solution is we don’t overwrite and close the terminal standard fd. So if the tool decides to write to or read from the closed terminal, it could fail.</p><blockquote class="book-hint warning">The other conclusion we can make is that the shell doesn’t send <code>SIGHUP</code> to processes or groups it did not create, even if the process is in the same session where the shell is a session leader.</blockquote><h2 id=daemons>Daemons
<a class=anchor href=#daemons>#</a></h2><p>A <code>daemon</code> is a long living process. It is often started at the system’s launch and service until the OS shutdown. Daemon runs in the background without a controlling terminal. The latest guarantees that the process never gets terminal-related signals from the kernel: <code>SIGINT</code>, <code>SIGTSTP</code>, and <code>SIGHUP</code>.</p><p>The classic “unix” way of spawning daemons is performed by a double-fork technique. After both <code>fork()</code> calls the parents exit immediately.</p><ol><li>The first <code>fork()</code> is needed:<ol><li>to become a child of the <code>systemd</code> process with <code>PID</code> 1;</li><li>if a daemon starts manually from a terminal, it puts itself into the background and a shell doesn’t know about it, so it can’t terminate the daemon easily;</li><li>the child is guaranteed not to be a process group leader, so the following <code>setsid()</code> call starts a new session and breaks a possible connection to the existing controlling terminal.</li></ol></li><li>The second <code>fork()</code> is done in order to stop being the session leader. This step protects a daemon from opening a new controlling terminal, as only a session leader can do that.</li></ol><p>The <code>gnu</code> provides a convininet <code>libc</code> function to demonize our program: <code>daemon()</code> <a href=https://man7.org/linux/man-pages/man3/daemon.3.html target=_blank rel=noopener><code>man 3 daemon</code></a>.</p><p>But nowadays, systems with <code>systemd</code> tend not to follow the double-fork trick. Instead developers highly rely on <code>systemd</code> features:</p><ul><li><code>systemd</code> can starts a new process session for daemons;</li><li>it can swap the standard file descriptors for <code>stdin</code>, <code>stdout</code> and <code>stderr</code> with regular files or sockets instead of manually close or redirect them to <code>syslog</code>. For example <code>nginx</code> <a href=https://github.com/nginx/nginx/blob/8e9f7e89b819702532803f10f728b070f8ee2617/src/os/unix/ngx_daemon.c#L46 target=_blank rel=noopener>code</a>:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>   fd <span style=color:#f92672>=</span> <span style=color:#a6e22e>open</span>(<span style=color:#e6db74>&#34;/dev/null&#34;</span>, O_RDWR);
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>dup2</span>(fd, STDIN_FILENO) <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>ngx_log_error</span>(NGX_LOG_EMERG, log, ngx_errno, <span style=color:#e6db74>&#34;dup2(STDIN) failed&#34;</span>);
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> NGX_ERROR;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   ...
</span></span></code></pre></div><p>So, a daemon can continue safely write to the <code>stderr</code> and <code>stdout</code> and don’t be afraid of getting the <code>EOF</code> because of a closed terminal. The <a href=https://www.freedesktop.org/software/systemd/man/systemd.exec.html target=_blank rel=noopener>following setting controls</a> that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>StandardOutput<span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>StandardError<span style=color:#f92672>=</span>
</span></span></code></pre></div><p>For instance, <code><a href=https://etcd.io/ target=_blank rel=noopener>etcd</a></code> service doesn&rsquo;t do a double-fork and fully rely on the <code>systemd</code>. That’s why its <code>PID</code> is a <code>PGID</code> and <code>SID</code>, so it’s a session leader.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat /proc/10350/stat | cut -d <span style=color:#e6db74>&#34; &#34;</span> -f 1,4,5,6,7,8 | tr <span style=color:#e6db74>&#39; &#39;</span> <span style=color:#e6db74>&#39;\n&#39;</span> | paste &lt;<span style=color:#f92672>(</span>echo -ne <span style=color:#e6db74>&#34;pid\nppid\npgid\nsid\ntty\ntgid\n&#34;</span><span style=color:#f92672>)</span> -
</span></span><span style=display:flex><span>pid 	<span style=color:#ae81ff>10350</span>
</span></span><span style=display:flex><span>ppid	<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>pgid	<span style=color:#ae81ff>10350</span>
</span></span><span style=display:flex><span>sid 	<span style=color:#ae81ff>10350</span>
</span></span><span style=display:flex><span>tty 	<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>tgid	-1
</span></span></code></pre></div><p>Also <code>systemd</code> has a lot of other features for modern service developers such as helpers for live upgrades, socket activation, sharing sockets, <code>cgroup</code> limits, etc&mldr;</p><a href=/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/ class="book-btn right-button">Read next chapter →</a></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#process-groups-jobs-and-sessions>Process groups, jobs and sessions</a><ul><li><a href=#process-groups>Process groups</a></li><li><a href=#sessions>Sessions</a></li><li><a href=#controlling-terminal-controlling-process-foreground-and-background-process-groups>Controlling terminal, controlling process, foreground and background process groups</a></li><li><a href=#shell-job-control>Shell job control</a></li><li><a href=#kill-command><code>kill</code> command</a></li><li><a href=#terminating-shell>Terminating shell</a></li><li><a href=#nohup-and-disown><code>nohup</code> and <code>disown</code></a></li><li><a href=#daemons>Daemons</a></li></ul></li></ul></nav></div></aside></main><div class=cookie-container><p>This website uses "<b>cookies</b>".
Using this website means you're OK with this.
If you are <b>NOT</b>, please close the site page.</p><button class=cookie-btn>
ACCEPT AND CLOSE</button></div><script src=/my_js/cookie.js></script></body></html>