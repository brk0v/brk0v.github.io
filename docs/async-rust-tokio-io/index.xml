<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Async Rust &amp; Tokio I/O Streams on Viacheslav Biriukov</title>
    <link>https://biriukov.dev/docs/async-rust-tokio-io/</link>
    <description>Recent content in Async Rust &amp; Tokio I/O Streams on Viacheslav Biriukov</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://biriukov.dev/docs/async-rust-tokio-io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Async Rust with Tokio I/O Streams: Backpressure, Concurrency, and Ergonomics</title>
      <link>https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/</guid>
      <description>&lt;h1 id=&#34;async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics&#34;&gt;&#xA;  Async Rust with Tokio I/O Streams: Backpressure, Concurrency, and Ergonomics&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p class=&#34;updated-right&#34;&gt;&#xA;    &lt;i&gt;&#xA;        &lt;time datetime=&#34;2025-10&#34;&gt;Last updated: Oct 2025&lt;/time&gt;&#xA;    &lt;/i&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/rust-tokio-io/&#34;&gt;1 Async Rust with Tokio IO Streams: Backpressure, Concurrency, and Ergonomics&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/#backpressure&#34;&gt;Backpressure&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/#cancellation&#34;&gt;Cancellation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/&#34;&gt;2. I/O loop&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#backpressure-propagation&#34;&gt;Backpressure propagation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#concurrency&#34;&gt;Concurrency&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/&#34;&gt;3. Tokio I/O Patterns&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#tcp-split-stream&#34;&gt;TCP split stream&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#split-generic-asyncreadasyncwrite-stream&#34;&gt;Split generic &lt;code&gt;AsyncRead+AsyncWrite&lt;/code&gt; stream&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#bidirectional-driver-for-io-without-split&#34;&gt;Bidirectional driver for I/O without split&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#framed-io&#34;&gt;Framed I/O&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#35-bidirectional-driver-for-framed-io&#34;&gt;Bidirectional driver for framed I/O&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr/&gt;&#xA;&lt;p&gt;There are many excellent, straightforward guides for getting started with Async Rust and Tokio. Most focus on the core building blocks: Tokio primitives, Rust futures, and concepts such as &lt;code&gt;Pin&lt;/code&gt;/&lt;code&gt;Unpin&lt;/code&gt;, and often finish with a simple TCP client-server sample. In fact, the typical tutorial example can usually be reduced to something as simple as:&lt;/p&gt;</description>
    </item>
    <item>
      <title>I/O loop</title>
      <link>https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/</guid>
      <description>&lt;h1 id=&#34;io-loop&#34;&gt;&#xA;  I/O loop&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#io-loop&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p class=&#34;updated-right&#34;&gt;&#xA;    &lt;i&gt;&#xA;        &lt;time datetime=&#34;2025-10&#34;&gt;Last updated: Oct 2025&lt;/time&gt;&#xA;    &lt;/i&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#backpressure-propagation&#34;&gt;Backpressure propagation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#concurrency&#34;&gt;Concurrency&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr/&gt;&#xA;&lt;p&gt;Before changing the code, let&amp;rsquo;s outline our goals for I/O loops:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Preserve backpressure propagation&lt;/strong&gt;: blocked writes should slow down the local producer over the &lt;code&gt;rx&lt;/code&gt; channel.&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Retain concurrency&lt;/strong&gt;: other work (e.g., cancellation, timeouts) should make progress while reads/writes are pending. Reads and writes should not block each other.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;backpressure-propagation&#34;&gt;&#xA;  Backpressure propagation&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#backpressure-propagation&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;To address the first issue we could flip the perspective: instead of eagerly pulling from the &lt;code&gt;rx&lt;/code&gt; channel, &lt;strong&gt;wait until the writer proves it has capacity&lt;/strong&gt;. Some async primitives support this. For example, &lt;code&gt;&lt;a href=&#34;https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Sender.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tokio::sync::mpsc::Sender&lt;/a&gt;&lt;/code&gt; offers &lt;code&gt;&lt;a href=&#34;https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Sender.html#method.reserve&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reserve()&lt;/a&gt;&lt;/code&gt;, which &lt;code&gt;await&lt;/code&gt;s for a slot to become available to write. When the permission is granted, we can dequeue the message from our &lt;code&gt;rx&lt;/code&gt; channel. But one important note here is that &lt;code&gt;mpsc&lt;/code&gt; is slot-based, and not byte-sized, which is not what we usually need when working with I/O streams.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Tokio I/O patterns</title>
      <link>https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/</guid>
      <description>&lt;h1 id=&#34;tokio-io-patterns&#34;&gt;&#xA;  Tokio I/O Patterns&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tokio-io-patterns&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h1&gt;&#xA;&lt;p class=&#34;updated-right&#34;&gt;&#xA;    &lt;i&gt;&#xA;        &lt;time datetime=&#34;2025-10&#34;&gt;Last updated: Oct 2025&lt;/time&gt;&#xA;    &lt;/i&gt;&#xA;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#tcp-split-stream&#34;&gt;TCP split stream&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#split-generic-asyncreadasyncwrite-stream&#34;&gt;Split generic &lt;code&gt;AsyncRead+AsyncWrite&lt;/code&gt; stream&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#bidirectional-driver-for-io-without-split&#34;&gt;Bidirectional driver for I/O without split&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#backpressure&#34;&gt;Backpressure&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#cancellation&#34;&gt;Cancellation&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#framed-io&#34;&gt;Framed I/O&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#35-bidirectional-driver-for-framed-io&#34;&gt;Bidirectional driver for framed I/O&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr/&gt;&#xA;&lt;p&gt;Now let&amp;rsquo;s look at the possible solutions and weigh their pros and cons.&lt;/p&gt;&#xA;&lt;h2 id=&#34;tcp-split-stream&#34;&gt;&#xA;  TCP split stream&#xA;  &lt;a class=&#34;anchor&#34; href=&#34;#tcp-split-stream&#34;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;&#xA;&lt;p&gt;The first obvious solution, suggested by the documentation, is to split the TCP stream into two parts: a reader and a writer.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
