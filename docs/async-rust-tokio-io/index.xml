<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Async Rust &amp; Tokio I/O Streams on Viacheslav Biriukov</title><link>https://biriukov.dev/docs/async-rust-tokio-io/</link><description>Recent content in Async Rust &amp; Tokio I/O Streams on Viacheslav Biriukov</description><generator>Hugo</generator><language>en-us</language><atom:link href="https://biriukov.dev/docs/async-rust-tokio-io/index.xml" rel="self" type="application/rss+xml"/><item><title>Async Rust with Tokio I/O Streams: Backpressure, Concurrency, and Ergonomics</title><link>https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/</guid><description>&lt;h1 id="async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics"&gt;
 Async Rust with Tokio I/O Streams: Backpressure, Concurrency, and Ergonomics
 &lt;a class="anchor" href="#async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p class="updated-right"&gt;
 &lt;i&gt;
 &lt;time datetime="2025-10"&gt;Last updated: Oct 2025&lt;/time&gt;
 &lt;/i&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/rust-tokio-io/"&gt;1 Async Rust with Tokio IO Streams: Backpressure, Concurrency, and Ergonomics&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/#backpressure"&gt;Backpressure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/1-async-rust-with-tokio-io-streams-backpressure-concurrency-and-ergonomics/#cancellation"&gt;Cancellation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/"&gt;2. I/O loop&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#backpressure-propagation"&gt;Backpressure propagation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#concurrency"&gt;Concurrency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/"&gt;3. Tokio I/O Patterns&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#tcp-split-stream"&gt;TCP split stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#split-generic-asyncreadasyncwrite-stream"&gt;Split generic &lt;code&gt;AsyncRead+AsyncWrite&lt;/code&gt; stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#bidirectional-driver-for-io-without-split"&gt;Bidirectional driver for I/O without split&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#framed-io"&gt;Framed I/O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#35-bidirectional-driver-for-framed-io"&gt;Bidirectional driver for framed I/O&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;p&gt;There are many excellent, straightforward guides for getting started with Async Rust and Tokio. Most focus on the core building blocks: Tokio primitives, Rust futures, and concepts such as &lt;code&gt;Pin&lt;/code&gt;/&lt;code&gt;Unpin&lt;/code&gt;, and often finish with a simple TCP client-server sample. In fact, the typical tutorial example can usually be reduced to something as simple as:&lt;/p&gt;</description></item><item><title>I/O loop</title><link>https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/</guid><description>&lt;h1 id="io-loop"&gt;
 I/O loop
 &lt;a class="anchor" href="#io-loop"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p class="updated-right"&gt;
 &lt;i&gt;
 &lt;time datetime="2025-10"&gt;Last updated: Oct 2025&lt;/time&gt;
 &lt;/i&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#backpressure-propagation"&gt;Backpressure propagation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/2-io-loop/#concurrency"&gt;Concurrency&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;p&gt;Before changing the code, let&amp;rsquo;s outline our goals for I/O loops:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Preserve backpressure propagation&lt;/strong&gt;: blocked writes should slow down the local producer over the &lt;code&gt;rx&lt;/code&gt; channel.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Retain concurrency&lt;/strong&gt;: other work (e.g., cancellation, timeouts) should make progress while reads/writes are pending. Reads and writes should not block each other.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="backpressure-propagation"&gt;
 Backpressure propagation
 &lt;a class="anchor" href="#backpressure-propagation"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;To address the first issue we could flip the perspective: instead of eagerly pulling from the &lt;code&gt;rx&lt;/code&gt; channel, &lt;strong&gt;wait until the writer proves it has capacity&lt;/strong&gt;. Some async primitives support this. For example, &lt;code&gt;&lt;a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Sender.html" target="_blank" rel="noopener"&gt;tokio::sync::mpsc::Sender&lt;/a&gt;&lt;/code&gt; offers &lt;code&gt;&lt;a href="https://docs.rs/tokio/latest/tokio/sync/mpsc/struct.Sender.html#method.reserve" target="_blank" rel="noopener"&gt;reserve()&lt;/a&gt;&lt;/code&gt;, which &lt;code&gt;await&lt;/code&gt;s for a slot to become available to write. When the permission is granted, we can dequeue the message from our &lt;code&gt;rx&lt;/code&gt; channel. But one important note here is that &lt;code&gt;mpsc&lt;/code&gt; is slot-based, and not byte-sized, which is not what we usually need when working with I/O streams.&lt;/p&gt;</description></item><item><title>Tokio I/O patterns</title><link>https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/</guid><description>&lt;h1 id="tokio-io-patterns"&gt;
 Tokio I/O Patterns
 &lt;a class="anchor" href="#tokio-io-patterns"&gt;#&lt;/a&gt;
&lt;/h1&gt;
&lt;p class="updated-right"&gt;
 &lt;i&gt;
 &lt;time datetime="2025-10"&gt;Last updated: Oct 2025&lt;/time&gt;
 &lt;/i&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#tcp-split-stream"&gt;TCP split stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#split-generic-asyncreadasyncwrite-stream"&gt;Split generic &lt;code&gt;AsyncRead+AsyncWrite&lt;/code&gt; stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#bidirectional-driver-for-io-without-split"&gt;Bidirectional driver for I/O without split&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#backpressure"&gt;Backpressure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#cancellation"&gt;Cancellation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#framed-io"&gt;Framed I/O&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://biriukov.dev/docs/async-rust-tokio-io/3-tokio-io-patterns/#35-bidirectional-driver-for-framed-io"&gt;Bidirectional driver for framed I/O&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;p&gt;Now let&amp;rsquo;s look at the possible solutions and weigh their pros and cons.&lt;/p&gt;
&lt;h2 id="tcp-split-stream"&gt;
 TCP split stream
 &lt;a class="anchor" href="#tcp-split-stream"&gt;#&lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The first obvious solution, suggested by the documentation, is to split the TCP stream into two parts: a reader and a writer.&lt;/p&gt;</description></item></channel></rss>