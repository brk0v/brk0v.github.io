<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>What every SRE should know on Viacheslav Biriukov</title><link>http://localhost:1313/</link><description>Recent content in What every SRE should know on Viacheslav Biriukov</description><generator>Hugo</generator><language>en-us</language><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml"/><item><title>GNU/Linux shell related internals</title><link>http://localhost:1313/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/</guid><description>What every SRE should know about GNU/Linux shell related internals: file descriptors, pipes, terminals, user sessions, process groups and daemons # Despite the era of containers, virtualization, and the rising number of UI of all kinds, SREs often spend a significant part of their time in GNU/Linux shells. It could be debugging, testing, developing, or preparing the new infrastructure. It may be the good old bash, the more recent and fancy zsh, or even fish or tcsh with their interesting and unique features.</description></item><item><title>Linux Page Cache for SRE</title><link>http://localhost:1313/docs/page-cache/0-linux-page-cache-for-sre/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/0-linux-page-cache-for-sre/</guid><description>SRE deep dive into Linux Page Cache # In this series of articles, I would like to talk about Linux Page Cache. I believe that the following knowledge of the theory and tools is essential and crucial for every SRE. This understanding can help both in usual and routine everyday DevOps-like tasks and in emergency debugging and firefighting. Page Cache is often left unattended, and its better understanding leads to the following:</description></item><item><title>What every SRE should know about GNU/Linux resolvers and Dual-Stack applications</title><link>http://localhost:1313/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/0-sre-should-know-about-gnu-linux-resolvers-and-dual-stack-applications/</guid><description>What every SRE should know about GNU/Linux resolvers and Dual-Stack applications # In this series of posts, I’d like to make a deep dive into the GNU/Linux local facilities used to convert a domain name or hostname into IP addresses, specifically in the context of dual-stack applications. This process of resolution is one of the oldest forms of networking abstraction, designed to replace hard-to-remember network addresses with human-readable strings. Although it may seem simple at first glance, the entire process involving stub resolvers is filled with complexities and subtle nuances.</description></item><item><title>File descriptor and open file description</title><link>http://localhost:1313/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/</guid><description>File descriptor and open file description # First of all, I want to touch on the two fundamental concepts of working with files:
file descriptor; open file description. These two abstractions are crucial for understanding the internals of a process creation, communication, and data transition.
The first concept is a file descriptor or fd. It’s a positive integer number used by file system calls instead of a file path in order to make a variety of operations.</description></item><item><title>Prepare environment for experiments</title><link>http://localhost:1313/docs/page-cache/1-prepare-environment-for-experiments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/1-prepare-environment-for-experiments/</guid><description>Prepare environment for experiments # Before starting, I want to be on the same page with the reader so that any example or code snippet can be executed, compiled, and checked. Therefore we need a modern GNU/Linux installation to play with code and kernel.
If you are using Windows or Mac OS, I would suggest installing Vagrant with Virtual Box. For the GNU/Linux distributive, I&amp;rsquo;d like to use Arch Linux.</description></item><item><title>What is a stub resolver?</title><link>http://localhost:1313/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/1-what-is-a-stub-resolver/</guid><description>1. What is a stub resolver? # First of all, let’s shed some light on what a stub resolver is.
Whenever someone begins talking about hostname resolution issues or nameserver changes, the first thing most people think of is the /etc/resolv.conf configuration file. Indeed, /etc/resolv.conf is a core and fundamental part of the local resolver system, and we will discuss it in detail later in this series, including how it’s managed on modern GNU/Linux distributions with systemd.</description></item><item><title>History: gethostbyname() and old good friends</title><link>http://localhost:1313/docs/resolver-dual-stack-application/2-history-gethostbyname/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/2-history-gethostbyname/</guid><description>2. History: gethostbyname() and old good friends # Please do not use any of the code snippets from this chapter in your projects. They are provided solely for historical and educational purposes. Instead, you should use getaddrinfo(). The gethostbyname (man 3 gethostbyname) function first appeared in the 1980s and has been a part of the networking landscape ever since. Despite its obsoletion, some programs still use it. It was deprecated in POSIX.</description></item><item><title>Pipes</title><link>http://localhost:1313/docs/fd-pipe-session-terminal/2-pipes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/fd-pipe-session-terminal/2-pipes/</guid><description>Pipes # The pipe is a neat feature of the Linux kernel that allows us to build one-directional communication channels between related processes (often a parent and a child).
Pipes are usually well known from shells, where we use &amp;ldquo;|&amp;rdquo; symbol to build command pipelines. But first of all, the pipe is a system call, or actually, there are 2 of them: pipe() and pipe2() (man 2 pipe).
You can think of a pipe as a memory buffer with a byte stream API.</description></item><item><title>Essential Linux Page Cache theory</title><link>http://localhost:1313/docs/page-cache/2-essential-page-cache-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/2-essential-page-cache-theory/</guid><description>Essential Page Cache theory # First of all, let’s start with a bunch of reasonable questions about Page Cache:
What is the Linux Page Cache? What problems does it solve? Why do we call it «Page» Cache ? In essence, the Page Cache is a part of the Virtual File System (VFS) whose primary purpose, as you can guess, is improving the IO latency of read and write operations. A write-back cache algorithm is a core building block of the Page Cache.</description></item><item><title>getaddrinfo() and POSIX spec</title><link>http://localhost:1313/docs/resolver-dual-stack-application/3-getaddrinfo-and-posix-spec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/3-getaddrinfo-and-posix-spec/</guid><description>3. getaddrinfo() and POSIX spec # Thus, instead of the deprecated gethostbyname(), getaddrinfo() should be used within libc. The getaddrinfo() function is a POSIX-standardized function and is defined in RFC 3943. It is IP version agnostic and returns data structures that can be easily reused in subsequent socket API calls (such as socket(), connect(), sendto()).
First of all, if you have a codebase that uses gethostbyname() and you are looking to migrate to the modern getaddrinfo(), I have bad news: it’s not a drop-in replacement.</description></item><item><title>Process groups, jobs and sessions</title><link>http://localhost:1313/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/</guid><description>Process groups, jobs and sessions # A new process group is created every time we execute a command or a pipeline of commands in a shell. Inside a shell, a process group is usually called a job. In its turn, each process group belongs to a session. Linux kernel provides a two-level hierarchy for all running processes (look at Image 3 below). As such, a process group is a set of processes, and a session is a set of related process groups.</description></item><item><title>getaddrinfo() from glibc</title><link>http://localhost:1313/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/4-getaddrinfo-from-glibc/</guid><description>4. getaddrinfo() from glibc # The standard in POSIX describes only the behavior and interface of the getaddrinfo() function. However, the actual implementation can vary between different frameworks. In this chapter, we will examine the internals of the getaddrinfo() implementation from glibc version 2.39. In the GNU/Linux world the glibc remains the default C library for the overwhelming majority of systems.
4.1 Internals and design # Even though the main purpose of a stub resolver is to send DNS queries to a recursive server, the reality is more complex than that.</description></item><item><title>Terminals and pseudoterminals</title><link>http://localhost:1313/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/</guid><description>Terminals and pseudoterminals # Terminals come to us from the history of UNIX systems. Basically, terminals provided an API for the console utils (physical ones!) to generalize interaction with users. It includes ways of reading input and writing to it in two modes:
the canonical mode (default) – input is buffered line by line and read into after a new line char \n occurs; the noncanonical mode – an application can read terminal input a character at a time.</description></item><item><title>getaddrinfo() from musl libc</title><link>http://localhost:1313/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/5-getaddrinfo-from-musl-libc/</guid><description>5. getaddrinfo() from musl libc # musl libc is a lightweight, fast, and simple implementation of the standard C library (libc) that aims for efficiency, standards compliance, and security.
It gained popularity following its extensive use in Alpine Linux, a security-oriented, lightweight Linux distribution often used as a base image for Docker containers.
However, it is crucial for us to understand that musl libc incorporates a completely new resolver code that behaves differently in certain situations.</description></item><item><title>Page Cache and basic file operations</title><link>http://localhost:1313/docs/page-cache/3-page-cache-and-basic-file-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/3-page-cache-and-basic-file-operations/</guid><description>Page Cache and basic file operations # Now it&amp;rsquo;s time to roll up our sleeves and get started with some practical examples. By the end of this chapter, you will know how to interact with Page Cache and which tools you can use.
Utils needed for this section:
sync (man 1 sync) – a tool to flush all dirty pages to persistent storage; /proc/sys/vm/drop_caches (man 5 proc) – the kernel procfs file to trigger Page Cache clearance; vmtouch – a tool for getting Page Cache info about a particular file by its path.</description></item><item><title>Dual-Stack applications</title><link>http://localhost:1313/docs/resolver-dual-stack-application/6-dual-stack-applications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/6-dual-stack-applications/</guid><description>6. Dual-Stack applications # Let’s now focus on dual-stack programs, which support both IPv4 and IPv6. Here are some critical questions to consider:
For server code:
How can we easily listen on all IPv4 and all IPv6 addresses? Do we need separate listeners for each? Are there any tools or helpers available to manage multiple listeners? For client code:
Which address family should our client program resolve and use: A, AAAA, or both?</description></item><item><title>Async non-blocking resolvers in C</title><link>http://localhost:1313/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/7-async-non-blocking-resolvers-in-c/</guid><description>7. Async non-blocking resolvers in C # Now that we’ve covered the essential theory, let’s explore alternative stub resolver libraries and frameworks for the C language. Other languages will be discussed next, but don’t skip this chapter, as it contains foundational information that will be referenced later.
7.1 getaddrinfo_a() # getaddrinfo_a (man 7 getaddrinfo_a) is an asynchronous version of getaddrinfo() but with some limitations: results can be collected by polling or notified by a signal.</description></item><item><title>Page Cache eviction and page reclaim</title><link>http://localhost:1313/docs/page-cache/4-page-cache-eviction-and-page-reclaim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/4-page-cache-eviction-and-page-reclaim/</guid><description>Page Cache eviction and page reclaim # So far, we have talked about adding data to Page Cache by reading and writing files, checking the existence of files in the cache, and flushing the cache content manually. But the most crucial part of any cache system is its eviction policy, or regarding Linux Page Cache, it&amp;rsquo;s also the memory page reclaim policy. Like any other cache, Linux Page Cache continuously monitors the last used pages and makes decisions about which pages should be deleted and which should be kept in the cache.</description></item><item><title>Stub resolvers in languages</title><link>http://localhost:1313/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/8-stub-resolvers-in-languages/</guid><description>8. Stub resolvers in languages # Let’s now take a look at other popular languages and understand the capabilities, features and options they provide in the context of resolvers.
8.1 Python # We are going to talk about cpython 3.12.
8.1.1 Stub resolvers # The Python standard library provides socket.getaddrinfo():
socket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0) which internally calls libc getaddrinfo():
/* Python interface to getaddrinfo(host, port). */ /*ARGSUSED*/ static PyObject * socket_getaddrinfo(PyObject *self, PyObject *args, PyObject* kwargs) { .</description></item><item><title>Dual-stack software examples</title><link>http://localhost:1313/docs/resolver-dual-stack-application/9-dual-stack-software-examples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/9-dual-stack-software-examples/</guid><description>9. Dual-stack software examples # 9.1 Nginx # Nginx treats the hostname as a set of distinct entries rather than multiple paths to the same host. From the upstream module doc:
A domain name that resolves to several IP addresses defines multiple servers at once.
On start Nginx resolves all hostnames using its static resolver with getaddrinfo() and the AF_UNSPEC and the AI_ADDRCONFIG flags.
ngx_int_t ngx_inet_resolve_host(ngx_pool_t *pool, ngx_url_t *u) { .</description></item><item><title>More about mmap() file access</title><link>http://localhost:1313/docs/page-cache/5-more-about-mmap-file-access/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/5-more-about-mmap-file-access/</guid><description>More about mmap() file access # Before we start the cgroup chapter, where I&amp;rsquo;m showing how to leverage memory and IO limits in order to control Page Cache eviction and improve the reliability of services, I want to delve a bit deeper into mmap() syscall. We need to understand what is happening under the hood and shed more light on the reading and writing process with mmap().
mmap() overview # Memory mapping is one of the most interesting features of Linux systems.</description></item><item><title>systemd-resolved</title><link>http://localhost:1313/docs/resolver-dual-stack-application/10-systemd-resolved/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/10-systemd-resolved/</guid><description>10. systemd-resolved # 10.1 Managing /etc/resolv.conf content # The main issue with /etc/resolv.conf is managing it in modern distributions, which can have multiple sources of nameserver and search domain information due to multiple interfaces (both real and virtual, such as VPN tunnels) with concurrent DHCP clients.
The legacy method to handle this complexity was the Resolvconf project. It set up a number of hooks and updated /etc/resolv.conf appropriately by following some defined rules.</description></item><item><title>Cgroup v2 and Page Cache</title><link>http://localhost:1313/docs/page-cache/6-cgroup-v2-and-page-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/6-cgroup-v2-and-page-cache/</guid><description>Cgroup v2 and Page Cache # The cgroup subsystem is the way to distribute and limit system resources fairly. It organizes all data in a hierarchy where the leaf nodes depend on their parents and inherit their settings. In addition, the cgroup provides a lot of helpful resource counters and statistics.
The control groups are everywhere. Even though you may not use them explicitly, they are already turned on by default in all modern GNU/Linux distributives and got integrated into systemd.</description></item><item><title>Querying Nameservers on dual-stack hosts</title><link>http://localhost:1313/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/11-querying-nameservers-on-dual-stack-hosts/</guid><description>11. Querying Nameservers on dual-stack hosts # The already seen RFC 8305 Happy Eyeballs Version 2: Better Connectivity Using Concurrency force the same preference for IPv6 name servers as it does for establishing new connections:
If multiple DNS server addresses are configured for the current network, the client may have the option of sending its DNS queries over IPv4 or IPv6. In keeping with the Happy Eyeballs approach, queries SHOULD be sent over IPv6 first (note that this is not referring to the sending of AAAA or A queries, but rather the address of the DNS server itself and IP version used to transport DNS messages).</description></item><item><title>The Present and the future of resolvers and DNS related features</title><link>http://localhost:1313/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/12-present-and-future-of-resolvers-and-dns-related-features/</guid><description>12. The Present and the future of resolvers and DNS related features # Let me briefly review some important features and topics related to DNS, stub resolvers, and dual-stack applications. While these are beyond the scope of this series, they are worth mentioning.
12.1 New DNS record: HTTPS # DNS has introduced a new and interesting resource record called HTTPS. This record addresses problems related to web service clients. Typically, when a client has only a domain name without additional information, it connects using plain text port 80.</description></item><item><title>Troubleshooting tools for resolvers and DNS</title><link>http://localhost:1313/docs/resolver-dual-stack-application/troubleshooting-tools-for-resolvers-and-dns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/resolver-dual-stack-application/troubleshooting-tools-for-resolvers-and-dns/</guid><description>Tools for troubleshooting in one place # Let me reiterate and consolidate all the tools that can be used to troubleshoot applications and systems when the stub resolver is under suspicion.
• getent # man 1 getent
When you need to query hostname via all NSS modules:
$ getent host microsoft.com $ getent ahost microsoft.com • tcpdump # To dump in a user friendly format all requests to 53 port:</description></item><item><title>Unique set size and working set size</title><link>http://localhost:1313/docs/page-cache/7-how-much-memory-my-program-uses-or-the-tale-of-working-set-size/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/7-how-much-memory-my-program-uses-or-the-tale-of-working-set-size/</guid><description>How much memory my program uses or the tale of working set size # Currently, in the world of containers, auto-scaling, and on-demand clouds, it&amp;rsquo;s vital to understand the resource needs of services both in norman regular situations and under pressure near the software limits. But every time someone touches on the topic of memory usage, it becomes almost immediately unclear what and how to measure. RAM is a valuable and often expensive type of hardware.</description></item><item><title>Direct IO</title><link>http://localhost:1313/docs/page-cache/8-direct-io-dio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/8-direct-io-dio/</guid><description>Direct IO (DIO) (NOT READY) # As usual, there is always an exception to any rule. And Page Cache is no different. So let&amp;rsquo;s talk about file reads and writes, which can ignore Page Cache content.
Why it’s good # Some applications require low-level access to the storage subsystem and the linux kernel gives such a feature by providing O_DIRECT file open flag. This IO is called the Direct IO or DIO.</description></item><item><title>Advanced Page Cache observability and troubleshooting tools</title><link>http://localhost:1313/docs/page-cache/9-advanced-page-cache-observability-and-troubleshooting-tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/page-cache/9-advanced-page-cache-observability-and-troubleshooting-tools/</guid><description>Advanced Page Cache observability and troubleshooting tools # Let&amp;rsquo;s touch on some advanced tools we can use to perform low-level kernel tracing and debugging.
eBPF tools # First of all, we can use eBPF tools. The [bcc]https://github.com/iovisor/bcc and bpftrace are your friends when you want to get some internal kernel information.
Let&amp;rsquo;s take a look at some tools which come with it.
Writeback monitor # $ sudo bpftrace ./writeback.bt Attaching 4 probes.</description></item></channel></rss>