<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>üè† on Viacheslav Biriukov</title><link>https://biriukov.dev/</link><description>Recent content in üè† on Viacheslav Biriukov</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://biriukov.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>GNU/Linux shell related internals</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/0-sre-should-know-about-gnu-linux-shell-related-internals-file-descriptors-pipes-terminals-user-sessions-process-groups-and-daemons/</guid><description>What every SRE should know about GNU/Linux shell related internals: file descriptors, pipes, terminals, user sessions, process groups and daemons # Despite the era of containers, virtualization, and the rising number of UI of all kinds, SREs often spend a significant part of their time in GNU/Linux shells. It could be debugging, testing, developing, or preparing the new infrastructure. It may be the good old bash, the more recent and fancy zsh, or even fish or tcsh with their interesting and unique features.</description></item><item><title>Linux Page Cache for SRE</title><link>https://biriukov.dev/docs/page-cache/0-linux-page-cache-for-sre/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/0-linux-page-cache-for-sre/</guid><description>SRE deep dive into Linux Page Cache # In this series of articles I would like to talk about Linux Page Cache. I believe that the following knowledge of the theory and tools is essential and crucial for every SRE. This understanding can help both in usual and routine everyday DevOps-like tasks and in emergency debugging and firefighting. Page Cache is often left unattended, and its better understanding leads to:</description></item><item><title>File descriptor and open file description</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/1-file-descriptor-and-open-file-description/</guid><description>File descriptor and open file description # First of all, I want to touch on the two fundamental concepts of working with files:
file descriptor; open file description. These two abstractions are crucial for understanding the internals of a process creation, communication, and data transition.
The first concept is a file descriptor or fd. It‚Äôs a positive integer number used by file system calls instead of a file path in order to make a variety of operations.</description></item><item><title>Prepare environment for experiments</title><link>https://biriukov.dev/docs/page-cache/1-prepare-environment-for-experiments/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/1-prepare-environment-for-experiments/</guid><description>Prepare environment for experiments # Before I start, I want to be on the same page with the reader, so any example or any code snippet can be executed, compiled and checked. Therefore we need a modern GNU/Linux installation where we can play with code and kernel.
If you are using Windows or Mac OS, I would suggest installing Vagrant with Virtual Box. For the GNU/Linux distributive I&amp;rsquo;d like to use Arch Linux.</description></item><item><title>Pipes</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/2-pipes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/2-pipes/</guid><description>Pipes # The pipe is a neat feature of the Linux kernel that allows us to build one-directional communication channels between related processes (often a parent and a child).
Pipes are usually well known from shells, where we use ‚Äú|‚Äù symbol to build command pipelines. But first of all, the pipe is a system call, or actually, there are 2 of them: pipe() and pipe2() (man 2 pipe).
You can think of a pipe as a memory buffer with a byte stream API.</description></item><item><title>Essential Linux Page Cache theory</title><link>https://biriukov.dev/docs/page-cache/2-essential-page-cache-theory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/2-essential-page-cache-theory/</guid><description>Essential Page Cache theory # First of all let‚Äôs start with a bunch of reasonable questions about Page Cache:
What is the Linux Page Cache? What problems does it solve? Why do we call it &amp;ldquo;Page&amp;rdquo; Cache ? In essence the Page Cache is a part of Virtual File System (VFS) which main purpose, as you can guess, is improving IO latency of read and write operations. A write-back cache algorithm is a core building block of the Page Cache.</description></item><item><title>Process groups, jobs and sessions</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/3-process-groups-jobs-and-sessions/</guid><description>Process groups, jobs and sessions # A new process group is created every time we execute a command or a pipeline of commands in a shell. Inside a shell, a process group is usually called a job. In its turn, each process group belongs to a session. Linux kernel provides a two-level hierarchy for all running processes (look at Image 3 below). As such, a process group is a set of processes, and a session is a set of related process groups.</description></item><item><title>Terminals and pseudoterminals</title><link>https://biriukov.dev/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/fd-pipe-session-terminal/4-terminals-and-pseudoterminals/</guid><description>Terminals and pseudoterminals # Terminals come to us from the history of UNIX systems. Basically, terminals provided an API for the console utils (physical ones!) to generalize interaction with users. It includes ways of reading input and writing to it in two modes:
the canonical mode (default) ‚Äì input is buffered line by line and read into after a new line char \n occurs; the noncanonical mode ‚Äì an application can read terminal input a character at a time.</description></item><item><title>Page Cache and basic file operations</title><link>https://biriukov.dev/docs/page-cache/3-page-cache-and-basic-file-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/3-page-cache-and-basic-file-operations/</guid><description>Page Cache and basic file operations # Now it&amp;rsquo;s time to roll up our sleeves and get started with some practical examples. By the end of this chapter you will know how to interact with Page Cache and which tools you can use.
Utils needed for this section:
sync (man 1 sync) ‚Äì a tool to flush all dirty pages to persistent storage; /proc/sys/vm/drop_caches (man 5 proc) ‚Äì a kernel procfs file to trigger Page Cache clearance; vmtouch ‚Äì a tool for getting Page Cache info about a particular file by its path.</description></item><item><title>Page Cache eviction and page reclaim</title><link>https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/4-page-cache-eviction-and-page-reclaim/</guid><description>Page Cache eviction and page reclaim # So far, we have talked about adding data to Page Cache by reading and writing files, checking existence of files in the cache and flushing the cache content manually. But the most important part of any cache system is its eviction policy or regarding Linux Page Cache it&amp;rsquo;s also the memory page reclaim policy. Linux Page Cache, like any other cache, continuously monitors the last used pages, makes decisions about which pages should be deleted and which should be kept in the cache.</description></item><item><title>More about mmap() file access</title><link>https://biriukov.dev/docs/page-cache/5-more-about-mmap-file-access/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/5-more-about-mmap-file-access/</guid><description>More about mmap() file access # Before we start the cgroup chapter, where I&amp;rsquo;m showing how to leverage memory and IO limits in order to control Page Cache eviction and improve reliability of services, I want to delve a bit deeper into mmap() syscall. We need to understand what is happening under the hood and shed more light on the process of reading and writing with mmap().
mmap() overview # Memory mapping is one of the most interesting features of the Linux systems.</description></item><item><title>Cgroup v2 and Page Cache</title><link>https://biriukov.dev/docs/page-cache/6-cgroup-v2-and-page-cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/6-cgroup-v2-and-page-cache/</guid><description>Cgroup v2 and Page Cache # The cgroup subsystem is the way to fairly distribute and limit system resources. It organizes all data in a hierarchy where the leaf nodes depend on their parents and inherit their settings. In additional, the cgroup provides a lot of useful resource counters and statistics.
The control groups are everywhere. Even though you may not use them explicitly, they are already turned on by default in all modern GNU/Linux distributives and got integrated in systemd.</description></item><item><title>Unique set size and working set size</title><link>https://biriukov.dev/docs/page-cache/7-how-much-memory-my-program-uses-or-the-tale-of-working-set-size/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/7-how-much-memory-my-program-uses-or-the-tale-of-working-set-size/</guid><description>How much memory my program uses or the tale of working set size # Currently, in the world of containers, auto-scaling and on-demand clouds, it&amp;rsquo;s very important to understand the resource needs of services both in norman regular situations and under pressure near the software limits. But every time someone touches on the topic of memory usage, it becomes almost immediately unclear what and how to measure. RAM is valuable and often expensive type of hardware.</description></item><item><title>Direct IO</title><link>https://biriukov.dev/docs/page-cache/8-direct-io-dio/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/8-direct-io-dio/</guid><description>Direct IO (DIO) (NOT READY) # As usual, there is always an exception in any rule. And Page Cache is not different. So let&amp;rsquo;s talk about file reads and writes which can ignore Page Cache content.
Why it‚Äôs good # Some applications require low-level access to the storage subsystem and linux kernel gives such feature by providing O_DIRECT file open flag. This IO is called the Direct IO or DIO.</description></item><item><title>Advanced Page Cache observability and troubleshooting tools</title><link>https://biriukov.dev/docs/page-cache/9-advanced-page-cache-observability-and-troubleshooting-tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://biriukov.dev/docs/page-cache/9-advanced-page-cache-observability-and-troubleshooting-tools/</guid><description>Advanced Page Cache observability and troubleshooting tools # Let&amp;rsquo;s touch some advanced tools that we can use in order to perform a low level kernel tracing and debugging.
eBPF tools # First of all we can use eBPF tools. The [bcc]https://github.com/iovisor/bcc and bpftrace are your friends when you want to get some internal kernel information.
Let&amp;rsquo;s take a look at some tools which come with.
Writeback monitor # $ sudo bpftrace .</description></item></channel></rss>